\documentclass[thesis.tex]{subfiles}
\begin{document}
\chapter{Instantiating and Evaluating SecPAL}
\label{chap:apppal}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/policies-ecosystem.pdf}
  \caption[Entities in the mobile ecosystem]{Entities in the mobile ecosystem
    and some of the policies surrounding them.}
  \label{fig:ecosystem}
\end{figure}

The mobile ecosystem; which we defined as the devices, users, stores, developers
and policies surrounding the ways we use mobile devices; contains many
interacting entities. Entities include devices interacting with their users, app
stores selling software, developers building apps, wireless access points
devices connect to, and companies and networks the devices and their users work
within.

Every entity in the ecosystem has its own policies. For example there is a
contract between the store selling apps and the developer programmging them. Not
all policies are as formal as a contract: a user may have preferences about
which kinds of apps he wants to install but may not write these preferences
down. Instead he might pick apps to install from a store based on his
best guess as to whether it matches his preferences. The mobile ecosystem has
a distributed structure. Phones, users and stores are not aware of each other
until they interact---there is no list of every app store, every device and
every user. They must make policy decisions on their own without relying on a
central authority to make decisions for them. They can, if required, delegate to
others for their policies and knowledge.

Formal languages let us write policies without ambiguity and describes precisely
the process behing making decisions. The policy written in the formal language
describes what decisions can be made. Translating policies into a formal
language allows for rigorous comparisons of different policies, preferences and
rules in mobile ecosystems. Writing the policy in a formal language allows it to
be checked automatically.

Becker~et~al{.} designed SecPAL to make access control decisions in distributed
systems~\cite{becker_secpal:_2010}. SecPAL is expressive, has a clear and
intuitive syntax, is decidable and extensible. That SecPAL is extensible is
important as we can apply the language to a new domain by instantiating it with
predicates and constraints.

This chapter introduces how SecPAL is instantiated to describe the policies
surrounding mobile ecosystems. I explain why I chose SecPAL to describe policies
in the mobile ecosystem. I introduce AppPAL as an instantiation and
implementation of SecPAL for mobile device policies.

\section{Why SecPAL}
\label{sec:why-apppal}

There are many policy languages. Some target specific domains: such as Ponder
which targets firewalls, OS's and databases~\cite{damianou_ponder_2001}. Others,
such as Cassandra, focus on credential management~\cite{becker_cassandra:_2004}.
Some are general like XACML~\cite{oasis_extensible_2013}: designed to express
access control decisions from a variety of domains. Different policy languages
are descrbied in greater detail in \autoref{chap:related-work}; however to
create a policy language to describe mobile ecosystems we chose to base the
language on SecPAL~\cite{becker_secpal:_2010}.

The mobile ecosystem as described in \autoref{sec:mobile-ecosystem} has specific
requirements for a policy language to describe it's policies. Namely we need a
policy language that can express:

\begin{description}
  \item[Locality and Delegation.]
    In the mobile ecosystem different devices can have very different policies.
    Two users may disagree about what makes an app \emph{installable}. Equally, the
    policies a store may wish to enforce are very different from the policies a user
    may wish to enforce. Each entity in the ecosystem also expects to enforce their
    own policies---there is no overarching enforcer of policies, rather users
    enforce whatever preferences they have, stores enforce their own rules through
    whatever means they see fit. Sometimes entities may wish to share information
    and policy excerpts. A user might delegate to an expert user to help them decide
    what policies they want to use. A store might use information from an app
    vetting firm to decide what apps to sell.

  \item[Extensibility.]
    SecPAL's flexibility makes it
    ideal to work with in mobile domains as the breadth of policies is large.
    Users want to pick apps from stores, who in turn want to pick apps from
    developers.  A user might want to restrict what data an app can have, and
    might rely on the device to enable permissions.  Devices have different OS's
    and different trust models with the servers they acquire information from
    and their users.  A policy language must be able to describe rules in all
    these domains to be suitable.

  \item[Access external information]. As part of an assertion, a SecPAL
    constraint can also contain a \emph{constraint}. The constraint can contain
    extra checks that use information from outside the information contained in
    SecPAL statements; for instance a policy author could have a rule that is only
    valid in the afternoon. To do this they might add a constraint which checks the
    time of day and is only valid after noon. Constraints can contain equality
    checks, and logical operators such as \emph{and, or, \emph{or} not}.
    Additionally, SecPAL can use constraints to refer to external functions, to
    bring in information from outside of the language.

    This external information is particularly useful for mobile ecosystems. We
    can introduce a constraint function that dynamically prompts the user on their
    phone to okay an action. We can start to create rules that depend on the user's
    current location, or time of day. For example a company boss might want to check
    what time their employees get into work. To do this the boss requires their
    employees install an app that gives him their location. Employees might allow
    their boss to check on them during the work day, but during the weekend and the
    evenings they'd rather their boss could not see where they were. One way they
    might enforce their policy would be to remove the location permissions from the
    app once they leave work, and enable them again in the mornings. This process is
    manual and error-prone: a user might forget. Alternatively a phone that could
    use SecPAL as part of its permission system, could be programmed to only allow
    that permission when the employee wishes it.

    As well as contextual information, such as the time of day or user's
    location, and system information from the user's phone; constraints can be used to run and access
    static analysis results.  These tools can infer complex app properties, but
    it isn't always clear to users when they need to be run and how they should
    be configured.  SecPAL's constraints give us a way where we can run and use
    results from these tools automatically as part of the policy checking
    process. SecPAL effectively acts as a \emph{glue layer} between the tools
    and their invocation.

\end{description}

SecPAL was chosen as other languages lacked features that SecPAL supported.
PolicyMaker~\cite{blaze_decentralized_1996} would support constraints, but is in
general intractable; whereas Becker proved a SecPAL policy was decidable in
polynomial time.  The RT family of
languages~\cite{li_datalog_2003,ninghui_li_design_2002,li_distributed_2003}
satisfy most of out needs, but it isn't clear how the policies express locality.
Furthermore these languages are role-based.  This makes them a natural fit for
scenarios that model credentials or employees authorizations within a company,
but the question of what \emph{role} different apps have becomes complex.
Ultimately SecPAL was chosen because it fit our needs, had a natural syntax and
semantics which could describe hypothetical policies surrounding the mobile
ecosystem.

\section{Examples of AppPAL}

AppPAL describes the policies in the mobile ecosystem.
One example of this might be a user selecting which apps they might want to use on their phone.
A user, Alice, might decide that an individual app (Angry Birds, for example) is okay to use on their phone.
\begin{lstlisting}
'alice' says 'com.rovio.angrybirds' isInstallable.
\end{lstlisting}
Having decided the app is the one they wish to use she tells the device's package manager that it must install the app.
The package manager might be an app store (such as the Play Store on Android: the \texttt{com.android.vending} APK file), a \ac{MDM} program such as iOS's \ac{VPP}, or an IT manager manually provisioning devices.
The user may not know who fills the role of the \emph{package manager} but most systems provide one nevertheless.
\begin{lstlisting}
'alice' says 'package-manager'
  mustInstall ('com.rovio.angrybirds').
'alice' says 'com.android.vending' can-act-as 'package-manager'.
\end{lstlisting}
Additionally Alice may allow her workplace to dictate some apps that they must install (a delegation).
\begin{lstlisting}
'workplace' says 'alice' mustInstall('com.microsoft.office.word').
'alice' says 'workplace' can-say
  'alice' must Install('com.microsoft.office.word').
\end{lstlisting}
This policy works with single apps.
Alice has decided which apps to install and has stated the apps she decided upon.
This is an accurate description of how user's currently interact with stores and their devices.
Users may have more complex rules for deciding what to install, but following the rules is, most likely, left to the user's own self-discipline.

In contrast policy languages allow for greater generality.
A cautious user may only install Android apps with certain permissions\footnote{Permissions are the access control mechanism for device features used by Android.}.
\begin{lstlisting}
'user' says App isInstallable
  if App hasntPermission('CAMERA'),
     App hasntPermission('INTERNET'),
\end{lstlisting}
Others may avoid apps that allow them to spend money within the app.
\begin{lstlisting}
'user' says App isInstallable
  if App cannotMakeInAppPurchases.
\end{lstlisting}
Some may rely on an \ac{AV} program installed on their phone.
The phone can only install apps checked by the \ac{AV} program.
\begin{lstlisting}
'user' says App:A isInstallable
  where runAV(A) = 'safe'.
\end{lstlisting}
Alternatively they may say if two or more of their friends are willing to recommend the app to them.
\begin{lstlisting}
'user' says App isInstallable
  if App isRecommendedBy(Friend1),
     App isRecommendedBy(Friend2)
  where Friend1 != Friend2.

'user' says Friend:F can-say
  App:A isRecommendedBy(F).
\end{lstlisting}

AppPAL gives a language for describing these decision-making processes. By
writing down policies in formal language we not only start to allow
machine-based decision-making, avoiding the need for user's self-control, but we
also can compare different policies. This goes beyond describing user's app
preferences. Consider the two largest mobile operating systems: Apple's iOS and
Google's Android. When comparing the systems Apple's is often described as a
\emph{walled-garden} whereas Android is an
\emph{open-platform}~\cite{barrera_secure_2011,enck_defending_2011}. Language
like this is informal. It hints at the differences without giving them
precisely.

Using AppPAL we can model the differences between the two systems and make more meaningful comparisons.
The \emph{walled-garden} comments relate to their different app store models.
Users of iOS can only install apps from the App Store\footnote{\emph{The App Store} is Apple's marketplace for selling apps, an \emph{app store} is a generic term for an on-device store selling apps.}.
If a user is willing to install a special certificate, from a developer or business, however they may install apps through the browser or a computer connected to the device.
Apple control these special certificates, issuing and revoking them.
They must also be authorized by the device's owner.
\begin{lstlisting}
'device' says App isInstallable
  if App hasBeenSignedBy(Cert),
     Cert hasIssuer('apple').

'device' says App isInstallable
  if App hasBeenSignedBy(Cert),
     Cert hasIssuer(X),
     'apple' hasAuthorized(X),
     'device' hasOwner(U),
     U hasAuthorized(Cert)
  where validCertificate(App, Cert) = true.

'device' says Authority:A can-say A hasAuthorized(Certificate:C).
\end{lstlisting}
In contrast an Android user is free to install any signed app (though who signed it is not immediately important).
Unless the user has enabled \emph{side-loading} through the settings app, the app must come from the Play Store, as opposed to a file downloaded through another app store or the internet.
Alternatively if the user has enabled \emph{developer-mode}, again through the settings, then they may install apps through the \ac{ADB}.
\begin{lstlisting}
'device' says App isInstallable
  if App hasSource('play-store'),
     App hasBeenSignedBy(Cert)
  where validCertificate(App, Cert) = true.

'device' says App isInstallable
  if App hasSource('file')
     'device' hasOwner(U),
     U hasAuthorized('sideloading'),
     App hasBeenSignedBy(Cert)
  where validCertificate(App, Cert) = true.

'device' says 'settings-app' can-say
  U hasAuthorized('sideloading').

'device' says App isInstallable
  if App hasSource('adb')
     'device' hasOwner(U),
     U hasAuthorized('developer-mode').

'device' says 'settings-app' can-say
  U hasAuthorized('developer-mode').

'settings-app' says 'user' can-say
  'user hasAuthorized(Setting:X).
\end{lstlisting}
This glosses over some of the details of certificate handling (though the example could be extended further).
It also ignores how the system might update apps.
It does, however, provide a far more precise version of the differences in app installation between the two platforms.
For iOS, to install an app Apple have to authorize it, either by signing the app or the issuer.
In contrast for Android, to the device can install any app if the device owner is willing to enable the relevant setting.

%\todo{How do we know this is correct?}

\subsection{Worked Example}

As a worked example consider a user Alice, trying to install an app on her work phone.
Alice works for a hospital trust: they have a published mobile device policy.%~\cite{kennington_mobiles_2014}.
There policy states that if Alice wants to install an app she has to clear it with her immediate manager.
If it is for clinical use then she also has to clear it with the \ac{CACPG}.
If it is for business use then she also has to clear it with the \ac{MIG}.
Finally the \ac{IGC} should clear the app.
This is a relatively complicated policy requiring, but it is also a realistic one.
The rule itself comes from an actual NHS trust's BYOD rules~\cite{kennington_mobiles_2014}.

To implement the policy they publish the following AppPAL rules:
\begin{lstlisting}
'nhs-trust' says App isUsable
  if App hasMet('clinical-use-case').

'nhs-trust' says App isUsable
  if App hasMet('business-use-case').

'nhs-trust' says 'cacpg' can-say
  App:A hasMet('clinical-use-case').

'nhs-trust' says 'mig' can-say
  App:A hasMet('business-use-case').

'nhs-trust' says App isInstallable
  if App hasMet('final-app-approval'), App isUsable.

'nhs-trust' says 'igc' can-say
  App hasMet('final-app-approval').

'nhs-trust' says Device canInstall(App)
  if App isInstallable, App isApprovedFor(Device).

'nhs-trust' says Employee:Manager can-say
  App:A isApprovedFor(Device)
  if Manager isResponsibleFor(Device).
\end{lstlisting}

Alice wishes to install the app \emph{\ttfamily ms.office} for business purposes.
To satisfy the policy and install the app she needs to collect the following statements.

\begin{itemize}
    %\newand{\weitemsize}[0]{\footnotesize}
  \item \lstinline!'nhs-trust' says 'ms.office' isInstallable.!
    For this, she needs the \ac{MIG} to state that it has a business use-case.
    She also needs approval from the \ac{IGC}.
    \begin{enumerate}\setcounter{enumi}{0}
      \item \lstinline!'mig' says 'ms.office' hasMet('business-use-case').!
      \item \lstinline!'igc' says 'ms.office' hasMet('final-app-approval').!
    \end{enumerate}
  \item \lstinline!'nhs-trust' says 'ms.office' isApprovedFor('alices-device').!
    To get this she needs a statement from the manager responsible for Alice's device (\emph{Bob}) approving the app.
    \begin{enumerate}\setcounter{enumi}{2}
      \item \lstinline!'bob' says 'ms.office' isApprovedFor('alices-device').!
      \item \lstinline!'nhs-trust' says 'bob' isResponsibleFor('alices-device').!
    \end{enumerate}
  \item Additionally, she needs the following typing statements.
    \begin{enumerate}\setcounter{enumi}{4}
      \item \lstinline!'nhs-trust' says 'ms.office' isApp.! \label{item:isapp}
      \item \lstinline!'nhs-trust' says 'bob' isEmployee.!
    \end{enumerate}
\end{itemize}

Alice obtains the statements by contacting the speakers.
Each may either give her the statement she needs or may give her more rules.
For example, the \ac{MIG} and \ac{IGC} may authorize the app or they might give a list of additional checks they need before they agree to authorize the app.
When checking if the app is an App in \autoref{item:isapp}, the NHS trust might delegate further.
They could reply that if the App is in the Google Play store then they recognise it as a valid app.
Alice would then have to get more assertions if she wanted to prove this statement.
%As with SecPAL, all statements should have a signature from their speaker proving they said the statement.
Alternatively, the speaker could refuse to make the assertion, either because they do not believe it, or they cannot give an answer.
In this case, Alice would have to look for an alternative means to prove the assertion or accept that they cannot install the app.

Once she has collected the statements, she can use a SecPAL inference tool,
such as AppPAL, to check whether she can install the app.  Additional to the
decision, if a proof is found, a tool like AppPAL can output a proof
tree\footnote{Technically a DAG.} to show how it made the decision
(\autoref{fig:exemplar-proof}).  The proof tree shows the AppPAL assertions
used to prove each statement at varying levels of the tree: from the the top
level goal which, in this case, used the \emph{cond} rule.

\begin{center}
  \includegraphics[width=0.9\linewidth]{figures/exemplar-proof-1.png}
\end{center}

To later nodes which might use SecPAL's other rules to be proved (\emph{can-say} in this case).

\begin{center}
  \includegraphics[width=0.9\linewidth]{figures/exemplar-proof-2.png}
\end{center}

If two nodes depend on the same sub-goals then the proof will be reused.

\begin{center}
  \includegraphics[width=0.9\linewidth]{figures/exemplar-proof-3.png}
\end{center}

\begin{figure}
  \centering
  \includegraphics[width=0.9\textheight, angle=90]{figures/exemplar-proof.pdf}
  \caption[Proof tree output by AppPAL]{Proof tree generated by AppPAL when checking whether to install Alice's app.}
  \label{fig:exemplar-proof}
\end{figure}

\section{Instantiating SecPAL for mobile ecosystems}
\label{sec:instantiating}

SecPAL is a generic language.  In SecPAL's
grammar~(\autoref{fig:secpal-grammar}) predicates and constraint
functions that describe the decisions and checks done in a particular
domain.  The choice of predicates and constraints defines the
decisions the SecPAL instantiation can talk about.

AppPAL instantiates SecPAL to describe policies in mobile
ecosystems~\cite{hallett_apppal_2016}.  It was initially focussed on
describing app installation policies, however it was later extended
further to describe other policies, such as \ac{BYOD} policies.

\subsection{Predicate Conventions}
\label{ssec:types}

\newcommand{\descPred}[2]{\emph{subject} \texttt{\textbf{#1}\emph{#2}}}
\begin{table}
  \begin{tabular}{l l}
    \toprule
    Prefix                      & Meaning                                            \\
    \midrule
    \descPred{can}{Action}      & The subject is allowed to perform the action.      \\
    \descPred{has}{Action}      & The subject has performed the action.              \\
    \descPred{is}{Property}     & The property holds true for the subject.           \\
    \descPred{must}{Obligation} & The subject is required to satisfy the obligation. \\
    \bottomrule
  \end{tabular}
  \caption{Standard prefixes used for AppPAL predicates.}
  \label{tab:predicate-prefixes}
\end{table}

When instantiating SecPAL we use predicates based on four verbs: \emph{can}, \emph{has}, \emph{is} and \emph{must}.
These verbs describe facts common to many policies.
An \emph{is} predicate states that its subject has a given propery.
A \emph{can} predicate describes permissible actions.
For example in a \ac{BYOD} policy a company might describe what apps a device can install, and what company data a user can get access to.
A user might have a privacy preference describing what parts of their personal data an app can share.
App stores have steps to go through before a developer can sell their app~\cite{oberheide_dissecting_2012,google_google_2017}.
When we need to describe the conditions for an action going ahead we use the can statement.

\begin{description}
\item[\bfseries\texttt{subject \emph{is}Propery}]
  A statement that says the \emph{subject} has a given \emph{property}.
  A~common example of this is to restrict variables to a given type.
  An example might be that \lstinline!'anrgry-birds' isApp! or that \lstinline!'jennie' isEmployee!.
  Constants in SecPAL are untyped (they are in effect just symbols) so it is
  often helpful to restrict their type to a given domain.  For example Alice
  might trust Bob to describe what apps are good, but not what websites.
  \begin{lstlisting}
'alice' says 'bob' can-say X isGood if X isApp.
  \end{lstlisting}
  Additionally SecPAL requires that all variables in the head of a statement be
  used in the body\footnote{The rule ensures that all queries terminate.}.
  Assigning a type by using an \emph{is} statement is sufficient to satisfy this rule.

  Not all constants or variables must have a property or type, but some may have multiple
  ones, for example an app might have the \emph{good} property, the \emph{app}
  type, and be \emph{installable}.  Each of these properties is expressed using
  the \emph{is} statement.  There is no obligation to provide a type to
  variables, but when writing policies we have found them helpful as they help
  specify precisely the domain a rule should operate on.

  \emph{Is} predicates are sometimes used as goals for queries, for example to test whether
  an app \emph{isInstallable} or not.  They also often occur frequently inside
  assertion bodies, as described.

\item[\bfseries\texttt{subject \emph{has}Action}]
  Describes actions the \emph{subject} has completed.
  For example if an app has requested a permission then we write:

  \lstinline!App:A hasRequestedPermission(Permission:P)!

  If a device requires its owner to grant a permission we might write:
  \begin{lstlisting}
'device' says User:U can-say
  App:A hasBeenGrantedPermission(Permission:P)
  if 'device' isOwnedBy(U).
  \end{lstlisting}

  Often predicates fall into common patterns and groups, for example
  \emph{hasRequested} and \emph{hasBeenGranted} here.  There is no requirement
  for the predicates to be named in such a way---\emph{hasBeenGranted} could be
  named \emph{canUseFeaturesAssociatedWith}.  In practice when describing
  policies it is best to be consistent and use just one predicate for one action
  or property to avoid confusion, redundant rules, and multiple ways of
  satisfying a policy.  In \autoref{sec:lint} an early implementation of a tool
  for checking for duplicated predicates is described.

  \emph{Has} predicates are rarely used as queries as they describe actions
  already taken.  They might be used as a goal if a policy needs to describe
  actions occuring in a given order.  For example, a~company might require that
  devices report if a user is using a company device unacceptably:

  \begin{lstlisting}
'company' says User:U hasBehavedUnacceptably
  if U hasAccessedWebpage(W),
     W isPornographic.
  \end{lstlisting}

\item[\bfseries\texttt{subject \emph{can}Action}]
  An authorization.
  The \emph{subject} may perform the \emph{action}.
  For example \lstinline!Device:D canInstall(App:A)! to say what apps a device can install or \lstinline!App:A canConnectTo(URL:U)! to describe a limitation on app network abilities.

  \emph{Can} predicates are frequently used as goals in queries.  They can be
  used to describe access control decisions, and as such are often the source of
  a query whether a subject \emph{can do} some action.

\item[\bfseries\texttt{subject \emph{must}Action}]
  An obligation.  The \emph{subject} should carry out the \emph{action}.
  An example might be requiring the device tell a company's IT department if there have been three unsuccessful password attempts:

  \begin{lstlisting}
'company' says Device:D mustInform('it', 'login-failure')
  if D hasUnsuccesfulLogins(N)
  where N >= 3.
  \end{lstlisting}

  AppPAL does not state how quickly a user should complete their obligation, or
  enforce that they even perform it.  These additional checks could be created
  by using additional predicates:

  \begin{lstlisting}
'mum' says 'alice' hasSatisfiedObligationToCall
  if 'alice' mustCall,
     'alice' hasCalled.
  \end{lstlisting}

  \emph{Must} predicates are mostly goals, as they describe the conditions when
  its subject must do something.  There are exceptions, such as the example
  above, but they are unusual.
\end{description}

\todo{Add table sumarising how often each type of predicate was used from BYOD paper}

This differs from the approach taken with the SecPAL4P and SecPAL4DSA~\cite{becker_framework_2009,aziz_secpal4dsa:_2011}.
Both these languages add extra phrases to SecPAL's grammar.
For example SecPAL4P adds a \emph{may} and \emph{will} phrase to describe whether to carry out an action.
If Alice, a policy author, wished to use SecPAL4P to say that someone can forget her email address she could write:\footnote{%
Example taken from~\cite{becker_framework_2009}  SecPAL4P also has relaxed safety rules, that permit the variables $x$ and $t$ to be in the head of the rule, but not the body.}
\begin{lstlisting}
Alice says x may delete Email within t
\end{lstlisting}
An analogous AppPAL rule would be:
\begin{lstlisting}
'alice' says User:X canDeleteWithin('email', Time:t)
  where currentTime() < t.
\end{lstlisting}
The AppPAL is arguably slightly less succinct, but more explicit than the SecPAL4DSA.

\subsubsection{Patterns with predicates}

Using the four predicate types we can start to build relationships between them.
We showed how a policy author could check an obligation was completed when
descrbing \emph{must} predicates.  Whilst a policy author could write these
rules by hand, AppPAL has tools to automate creating rules like this.

As well as automating creating the policy, we can also start to check other
properties to check the policy is well formed. Using the example of installing
an app; if \emph{Alice says Bob must install
  an app}, then it implies that there should be a rule where \emph{Alice says
Bob has installed that app}.  We might also expect there to be a rule that
\emph{Alice says Bob can install the app}.

This can be taken further: actions where Alice \emph{can} do something might
naturally lead to assertions where Alice \emph{has} done something.  If a policy
author wished to enforce this relationship then we can start to reason about how the
assertion context has changed over time.

\begin{table}\centering
  \begin{tabular}{l c l}
    \toprule
      $F(\phi)$ & $\Rightarrow$ & At sometime in the future $\phi$ is true. \\
      $P(\phi)$ & $\Rightarrow$ & At sometime in the past $\phi$ was true. \\
      $G(\phi)$ & $\Rightarrow$ & $\phi$ will always true. \\
      $H(\phi)$ & $\Rightarrow$ & $\phi$ was always true. \\
    \bottomrule
  \end{tabular}
  \caption{Summary of temporal operators from Prior~\cite{arthur_n._prior_past_1967}.}
  \label{tab:temporal-operators}
\end{table}

Using the temporal operators in \autoref{tab:temporal-operators}, we can start to write rules expressing the relationship between different predicates.
Taking the earlier example,  we might wish to add a rule that if Alice believes Bob has done something $\phi$, then she must have said he could do that thing in the past.

\begin{equation*}
  \infer{P\left(\exists AC^\prime~s.t.~AC^\prime, D^\prime \models \mathtt{A~says~B~can~\phi.}\right)}{%
    AC, D \models \mathtt{A~says~B~has~\phi.}}
\end{equation*}

Using this structure we could add a rule to AppPAL that all decisions from the past, will hold in the future.
This might enable us to reduce the size of the asserition context as once we have a statement that someone \emph{has} we can remove the respective \emph{can} assertions.
Alternatively if we prove the rule is false, i.e. at no point in the past did Alice permit Bob's action then we can detect something has gone wrong.

\begin{equation*}
  \infer{\bot}{%
  AC, D \models \mathtt{A~says~B~has~\phi.} & \neg P\left(\exists AC^\prime~s.t.~AC^\prime, D^\prime \models \mathtt{A~says~B~can~\phi.}\right)
  }
\end{equation*}

An AppPAL interpretter might implement this by requiring the \emph{can} statement be made before any equivalent \emph{has} statement is made.
Looking at a trace from an instance of an AppPAL interpreter with one AC (though which might import or remove assertions over time), the following trace would be valid, but if the statement in red was removed it would be rejected.

\begin{center}
  \begin{tabular}{c c l}
    \toprule
    $\vdots$ & $\vdots$ \\
    At $T_i$:   & \textcolor{BrickRed}{$AC_i, D \models \mathtt{A~says~B~can~\phi.}$} & \\
    $\vdots$ & $\vdots$ \\
    At $T_j$:   & $AC_j, D \models \mathtt{A~says~B~has~\phi.}$ & (j $>$ i) \\
    $\vdots$ & $\vdots$ \\
    \bottomrule
  \end{tabular}
\end{center}

Interesting examples are not just limited to \emph{can} and \emph{has}: 
if Alice says Bob \emph{must} do some $\phi$, then we would expect that at some point in the future (if not immediately) that Alice will say that Bob \emph{can} complete the obligation to $\phi$.  Furthermore we would also expect Alice to acknowledge that at some future point Bob \emph{has} done $\phi$ as she required.

\begin{equation*}
  \infer{F\left(\exists AC^\prime~s.t.~AC^\prime, D^\prime \models \mathtt{A~says~B~has~\phi.}\right)}{%
  F\left(\exists AC^{\prime}~s.t.~AC^{\prime}, D^{\prime} \models \mathtt{A~says~B~can~\phi.}\right) &
    AC, D \models \mathtt{A~says~B~must~\phi.}}
\end{equation*}

Using this interpretation of AppPAL's rules the following for an interpretter the following trace is valid; 
but if either statement in red was removed the interpreter would report an error.

\begin{center}
  \begin{tabular}{c c l}
    \toprule
    $\vdots$ & $\vdots$ \\
    At $T_i$:   & $AC_i, D \models \mathtt{A~says~B~must~\phi.}$ & \\
    $\vdots$ & $\vdots$ \\
    At $T_j$:   & \textcolor{BrickRed}{$AC_i, D \models \mathtt{A~says~B~can~\phi.}$} & \\
    $\vdots$ & $\vdots$ \\
    At $T_k$:   & \textcolor{BrickRed}{$AC_j, D \models \mathtt{A~says~B~has~\phi.}$} & (k $>$ i, k $>$ j) \\
    $\vdots$ & $\vdots$ \\
    \bottomrule
  \end{tabular}
\end{center}

Using four predicates to describe various decisions allows for complex interpretations on top of AppPAL.
In this work we have only hinted at some of these possibilities, however it may make an interesting avenue for future work.

\subsection{Type Notation}

When writing a policy, it is common, though not strictly always required, to use conditions in facts that limit the scope of a variable.
To do this we use \emph{is}-predicates, that give their subject a type.
For example \emph{Alice} might declare that \emph{Bob} is responsible for saying which apps she can install.
This can be written in SecPAL as follows:
\begin{lstlisting}
'alice' says 'bob' can-say App isInstallable
  if App isApp.
\end{lstlisting}
When writing this we added a condition \lstinline{if App isApp}, that Bob can only talk about Apps as being installable.
Generalising this pattern we use predicates starting with \emph{is} to give types to their subjects.
If a policy rule contains a lot of variables, however these typing conditions can become very verbose.
To simplify the policy rules, AppPAL adds a sugared notation for typing
statements by extending SecPAL's grammar for variables (\autoref{fig:type-changes}).

\begin{figure}\centering
  \newcommand{\nonterminal}[1]{$\langle$#1$\rangle$}
  \newcommand{\terminal}[1]{\textbf{#1}}
  \begin{tabular}{r c l}
    \footnotesize
    \nonterminal{E}         & $\Coloneqq$ & \nonterminal{Variable} $\vert$ \terminal{'constant'} \\
    \nonterminal{Variable}  & $\coloneqq$ & \new{\terminal{Type}\terminal{:}\terminal{Var}} $\vert$ \terminal{Var}
  \end{tabular}
  \caption[ Changes to SecPAL's syntax to support types. ]{Changes to SecPAL's
    syntax to support types.  Changed terms are shown in red.}
  \label{fig:type-changes}
\end{figure}

Expansion of the AppPAL types into SecPAL conditions is described in \autoref{lst:type-expansion}.
This is run when parsing AppPAL code, and adds a rule to AppPAL
  that if a variable in the head of an assertion has a type
  then it is removed and a condition that the variable is that type is added to the body of the assertion.
If a variable in the body of an assertion has a type; then it is an error.

\begin{figure}\centering
  AppPAL:
\begin{lstlisting}
X says T1:A predicate(T2:B, T3:C) 
  if ... .
\end{lstlisting}

  $\Downarrow$

  SecPAL:
\begin{lstlisting}
X says A predicate(B, C) 
  if A isT1, 
     B isT2, 
     C isT3, 
     ... .
\end{lstlisting}
  \caption{Desugaring from AppPAL to SecPAL.}
  \label{lst:type-expansion}
\end{figure}

%\SetKwFunction{FnExpandTypes}{Expand Types}
%\SetKwFunction{FnFact}{new Fact}
%\SetKwFunction{FnStr}{to String}
%\SetKwFunction{FnAdd}{Add}
%\begin{algorithm}
%  \Fn(){\FnExpandTypes}{Assertion}{
%    \For{v $\in$ Assertion.\FnHead{}}{
%      \If{$\exists$ v.\FnType{}}{
%        f $\gets$ \FnFact{v, ``is''+v.\FnType{}.\FnStr{}}\;
%        Assertion.\FnBody{}.\FnAdd{f}\;
%      }
%    }
%    \Return{Assertion}\;
%  }
%  \caption{Procedure used to expand types from AppPAL into SecPAL.}
%  \label{lst:type-expansion}
%\end{algorithm}

Using this sugared notation, the earlier example becomes:
\begin{lstlisting}
'alice' says 'bob' can-say App:A isInstallable
\end{lstlisting}

For a more complex example consider the following example taken from a BYOD policy.
\begin{lstlisting}
'company' says Device:D canConnectToAP(AP:X)
  if X isOwnedByCompany.
\end{lstlisting}

The rule states that the company will only allow devices to connect to company owned access points.
The syntactic sugar expands into the following equivalent policy.

\begin{lstlisting}
'company' says Device canConnectToAP(X)
  if X isOwnedByCompany,
     Device isDevice,
     X isAP.
\end{lstlisting}

This is a fairly simple refinement of SecPAL's syntax, but it improves the
readability. It avoids hiding the condition that the company must own the access
point amongst typing statements aiding readability. It also helps avoid errors
in policies caused by the policy author forgetting to give a type to a variable.

\section{Implementation}
\label{sec:implementation}

Our AppPAL implementation is a Java library, with roughly 5,000 lines of code.
The implementation is available online\footnote{\url{https://github.com/apppal/libapppal}}.
The library creates an AppPAL instance.
This instance can be given several policies to enforce. 
The architecture is shown in \autoref{fig:apppal-inputs-outputs}.
The instance is queried and will give decisions based on whether the queried assertion is valid according to the policy.
As part of the constraint checking AppPAL can also be connected to external databases, systems, and static analysis tools.
These can give AppPAL with more information external to that provided by SecPAL at the time of checking, and connect AppPAL to tools to enforce the policies.

Implementing AppPAL as a library allows us to embed into a variety of
situations.  AppPAL can be part of an app store checking the apps sold against
a policy.  Running on a device, AppPAL can check apps before installation by
the package manager.  There is also a command-line version which is useful for
testing and modelling policies.  Our implementation can make the inferences, on
an Android device or on a command line but it is not integrated into Android.
It is future work to evaluate how AppPAL policies mgiht work in practice and be
tied into a mobile operating system to enforce policies in practice.  This work
looks primarily and moddeling the policies and preference and providing a
framework for enforcement, rather than the enforcement itself.

The AppPAL interpreter implements SecPAL's evaluation rules (shown in~\autoref{fig:secpal-rules}) directly.
This differs from Becker's original description of SecPAL~\cite{becker_secpal:_2010} which describes evaluation through Datalog$^C$.
Datalog$^C$ is Datalog extended to support constraints~\cite{li_datalog_2003}.
Rather than implementing Datalog$^C$ and then AppPAL atop it (we could not find an existing implementation), AppPAL implements the evaluation rules directly.
Our implementation is na\"ive and not the optimal method for evaluating queries.
Faster solutions might use answer-set programming and an SMT solver to answer queries.
For all policies we tried though our implementation was fast enough---answering all but the most queries in seconds~\cite{hallett_apppal_2016}.  An app takes about 30 seconds to download and install\footnote{The time taken to download and install the YouTube app on iOS over Wifi.}. An extra second to check a policy seems reasonable, though future work could check what user's find acceptable.

\begin{figure}
  \centering
  \begin{eqnarray*}
    \infer[\textsf{\scriptsize cond}]{%
      AC, D \models A\textsf{~says~}fact\theta
    }{%
      \begin{array}[c]{c}
        \left(A\textsf{~says~}\textit{fact}\textsf{~if~}\textit{fact}_1, \ldots, \textit{fact}_k, c\right) \in AC \\
        AC,D\models A\textsf{~says~}\textit{fact}_i\theta \; \forall i \in \{1\cdots k\}
      \end{array}
      & \models{c\theta}
      & \textsf{vars}(\textit{fact}\theta) = \emptyset)
    }\\
    \infer[\textsf{\scriptsize can say}]{%
      AC, \infty \models A\textsf{~says~}\textit{fact}
    }{%
      AC, \infty \models A\textsf{~says~}B\textsf{~can~say}_D \textit{fact}
      & AC, D \models B\textsf{~says~}\textit{fact}
    } \\
    \infer[\textsf{\scriptsize can act as}]{%
      AC, D \models A\textsf{~says~}B~\textit{verbphrase}
    }{%
      AC, D \models A\textsf{~says~}B\textsf{~can~act~as~}C
      & AC, D \models A\textsf{~says~}C~\textit{verbphrase}
    }
  \end{eqnarray*}
  \caption[Inference rules used to evaluate {SecPAL}.]{The inference rules used to evaluate {SecPAL}. All {SecPAL} rules are
  evaluated in the context of a set of other assertions $AC$ as well as an
  allowed level of delegation $D$ which may be $0$ or $\infty$.}
\label{fig:secpal-rules}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{figures/apppal-evaluation.pdf}
  \caption{AppPAL's inputs and outputs}
  \label{fig:apppal-inputs-outputs}
\end{figure}

\subsection{Evaluation}
\label{ssec:evaluation-alg}

Pseudocode for AppPAL's evaluation algorithm is given in Algorithms~\cref{alg:eval1,alg:eval2,alg:eval3}.

To make queries against a policy AppPAL is first given one or more policy files.
AppPAL parses the files and adds the assertions within them to the \ac{AC}.
The AC is then preprocessed to extract more information; summarized in \autoref{tab:apppal-sets}.
If a constant is used before a \emph{says} statement, or it is used as the subject of a \emph{can-say} fact then the constant is marked as \emph{voiced}.
A constant is \emph{voiced} if it is the speaker of a statement or it is the subject of a \emph{can-say} fact.
A constant is a \emph{subject} is it is the subject of a fact.
The predicates used in the policy are also extracted and marked as \emph{derivable}.
This allows some queries to be decided automatically and some rules to be flagged as unusable in the assertion context.
This lets AppPAL reject some queries quickly: if a query has a speaker that isn't voiced then we cannot query what the speaker says.
If a rule relies on un-derivable predicates then it cannot be used to make decisions.

A results table is also created.
All ground facts in the assertion context are added to the results table as proven facts.
The table stores partial results and previously established proofs.
The table is indexed by queries and a delegation depth, partial results (i.e. that the evaluation of this query is ongoing).
This allows previous results to reused without re-computation or constraint re-evaluation.
It also prevents AppPAL proofs growing infinite in size (and the decision process not terminating).
If when searching for a proof we meet a query that we are currently evaluating, i.e.~one that exists higher in the current proof tree, we treat it as false.
Multiple queries will share the same results table until the table is cleared, or the AppPAL instance is stopped.

When evaluating the policy we also track which rules and predicates we have used.
From this we can reconstruct a proof tree that shows how AppPAL made a decision.
This allows an auditor to check the decision-making process and aids AppPAL's developers with debugging.

\begin{table}
  \centering
  \newcommand{\myset}[1]{\ensuremath{\text{\sffamily #1}}}
  \begin{tabular}{r l c}
    \toprule
    $c \in \myset{Voiced} \impliedby$     & $\exists \left(c \text{~says~} \cdots\right) \in \text{AC}$                        & $\bigvee$ \\
                                          & $\exists \left(\star \text{~says~} c \text{~can-say~} \cdots\right) \in \text{AC}$ &           \\
    $c \in \myset{Subjects} \impliedby$   & $\exists \left(\star \text{~says~} c\cdots\right) \in \text{AC}$                   & $\bigvee$ \\
                                          & $\exists \left(\cdots \text{~if~} \cdots,c~\star,\cdots\right) \in \text{AC},$     &           \\
                                          & $c \in \myset{Constants}$                                                          &           \\
    $p \in \myset{Derivable} \impliedby$  & $\exists \left( \cdots \star~p\left(\cdots\right) \cdots\right) \in \text{AC}$     &           \\
    \bottomrule                          \\
  \end{tabular}
  \caption{Sets used in AppPAL evaluation.}
  \label{tab:apppal-sets}
\end{table}

\begin{algorithm}
  \Fn(){\FnEvaluate{AC, Results Table, Query, D}}{
    \If{Results Table.\FnContains{(Query, D)}}{
      result $\gets$ {Results Table.\FnGet{(Query, D)}}\;
      \If{result.\FnValid{}}{
        \Return Result
      }
      \Else{
        \Return{Failure}
      }
    }
    \Else{
      Results Table.\FnSet{(Query, D), (Inprogress, p)}\;
      p $\gets$ \FnCond{AC, Results Table, Query, D}\;
      \If{p.\FnValid{}}{
        Results Table.\FnSet{(Query, D), (Proven, p)}\;
        \Return{(Proven, p)}\;
      }
      \Else{
        p $\gets$ \FnCanSayCanActAs{AC, Results Table, Query, D}\;
        \If{p.\FnValid{}}{
          Results Table.\FnSet{(Query, D), (Proven, p)}\;
          \Return{(Proven, p)}\;
        }
        \Else{
          Results Table.\FnSet{(Query, D), Failure}\;
          \Return{Failure}\;
        }
      }
    }
  }
  \caption{Pseudocode for evaluating a query.}
  \label{alg:eval1}
\end{algorithm}
\begin{algorithm}
  \ContinuedFloat
  \Fn(){\FnCanSayCanActAs{AC, Results Table, Query, D}}{
    \For{c $\in$ \FnConstants{AC}}{
      \If{c $\in$ \FnSubjects{AC}}{
        p $\gets$ \FnCanActAs{AC, Results Table, Query, D}\;
        \If{p.\FnValid{}}{\Return p}
      }
      \If{c $\in$ \FnSpeakers{AC}}{
        p $\gets$ \FnCanSay{AC, Results Table, Query, D}\;
        \If{p.\FnValid{}}{\Return p}
      }
    }
    \Return{Failure}
  }
  \caption{Pseudocode for using the can-say and can-act-as rules.}
  \label{alg:eval2}
\end{algorithm}
\begin{algorithm}
  \ContinuedFloat
  \Fn(){\FnCond{AC, Results Table, Query, D}}{
    \For{a $\in$ \FnAssertions{AC}}{
      u $\gets$ Query.\FnUnify{a.\FnHead{}}\;
      \If{u.\FnValid{}}{
        a $\gets$ a.\FnApply{u}
        \If{\FnVariables{a} = $\emptyset$}{
          \Return{\FnCheckBody{AC, Results Table, a, D}}
          \For{$\theta \in$ \FnVarSubs{AC, Assertion}}{
            a$^\prime$ $\gets$ a.\FnApply{$\theta$}\;
            \If{$\forall$ b $\in$ a$^\prime$.\FnBody{}: \FnEvaluate{AC, Results Table, b, D}.\FnValid{}}{
              p $\gets$ \FnCheckConstraint{a$^\prime$.\FnConstraint{}}\;
              \If{p.\FnValid{}}{\Return{p}}
            }
          }
        }
      }
    }
    \Return{Failure}
  }
    \caption{Pseudocode for using the cond-rule.}
    \label{alg:eval3}
\end{algorithm}

\subsection{Soundness o decision procedure}
\todo{You know you're going to have to do this.}

\subsection{Benchmarks}
\label{ssec:benchmarks}

Someone using AppPAL might wish it to check apps before installation.
Since policy checks may involve inspecting many rules and constraints one may ask whether the checking will be acceptably fast.
Downloading and installing an app takes about 30 seconds on a typical Android phone over Wifi.
If checking a policy delays this even further a user may become annoyed and disable AppPAL.

A synthetic benchmark is used to give a measure AppPAL's performance.
The policy checking procedure is at its slowest when having to delegate repeatedly;
  the depth of the delegation tree is the biggest reason for slowing the search.
Synthetic benchmarks checks that the checking procedure performed acceptably.
Each benchmark consisted of a chain of delegations.
The \emph{1 to 1} benchmark consists of a repeated delegation between all the principals.
In the \emph{1 to 2} benchmark each principal delegated to 2 others and in the \emph{1 to 3} benchmark each principal delegated to 3 others.
These benchmarks are reasonable as they model the slowest kinds of policies to test---though worse ones could be designed by delegating even more or triggering an expensive constraint check.

\noindent
\begin{minipage}{.32\textwidth}
\begin{lstlisting}[caption={Excerpt of policy from 1 to 1 benchmark.}, basicstyle=\ttfamily\footnotesize]
'0' says '1' can-say
  X isInstallable.
'1' says '2' can-say
  X isInstallable.
'2' says '3' can-say
  X isInstallable.
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.32\textwidth}
\begin{lstlisting}[caption={Excerpt of policy from 1 to 2 benchmark.}, basicstyle=\ttfamily\footnotesize]
'2' says '4' can-say
  X isInstallable.
'2' says '5' can-say
  X isInstallable.
'3' says '6' can-say
  X isInstallable.
'3' says '7' can-say
  X isInstallable.
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.32\textwidth}
\begin{lstlisting}[caption={Excerpt of policy from 1 to 3 benchmark.}, basicstyle=\ttfamily\footnotesize]
'4' says '12' can-say
  X isInstallable.
'4' says '13' can-say
  X isInstallable.
'4' says '14' can-say
  X isInstallable.
'5' says '15' can-say
  X isInstallable.
'5' says '16' can-say
  X isInstallable.
'5' says '17' can-say
  X isInstallable.
\end{lstlisting}
\end{minipage}

For each benchmark we controlled the number of principals in the policy file:
as the number of principals increased so did the size of the policy.
The results are shown in \autoref{tab:benchmarks}.
Most typical policies (such as those discussed in \autoref{chap:apps-and-stores} and \autoref{chap:byod}), use only few delegations per decision.
I believe the policy checking performance of AppPAL is acceptable as unless a policy consists of hundreds of delegating principals the overhead of checking an AppPAL policy is negligible, even on a power constrained device such as a mobile phone~\cite{hallett_apppal_2016}.

\begin{table}
  \centering\sffamily
    \begin{tabular}{c c r@{.}l}
      \toprule
      Delegations & Principals & \multicolumn{2}{c}{Time (s)} \\
      \midrule
      1 to 1 & 10   &  0&01 \\
      1 to 1 & 100  &  1&00 \\
      1 to 1 & 500  & 20&90 \\
      1 to 1 & 1000 & 88&73 \\
      \midrule
      1 to 2 & 10   &  0&01 \\
      1 to 2 & 100  &  0&43 \\
      1 to 2 & 500  &  7&36 \\
      1 to 2 & 1000 & 27&47 \\
      \midrule
      1 to 3 & 10   &  0&01 \\
      1 to 3 & 100  &  0&24 \\
      1 to 3 & 500  &  3&99 \\
      1 to 3 & 1000 & 15&28 \\
      \bottomrule
    \end{tabular}
    \includegraphics[width=1.00\linewidth]{figures/benchmarks.pdf}
  \caption{Benchmarking results on a Nexus 4 Android phone.}
  \label{tab:benchmarks}
\end{table}



\ignore{
  \bibliography{../thesis.bib}
}
\end{document}

% vim: set makeprg=make\ ch3.pdf:

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ch3.tex"
%%% End:
