    \documentclass[thesis.tex]{subfiles}
    \begin{document}
    \chapter{Related Work}
    \label{chap:related-work}

\section{XACML}

XACML is a standardised policy language~\cite{oasis_extensible_2013}
that can be extended to fit many scenarios. It is an attribute based
policy language, but can also describe role-based policies; and has
industrial support from \emph{Oracle}.  It is worthy of special
attention as it has become an extremely popular policy language from
both an industrial and academic standpoint.  As such it is important
to summarize and briefly describe why we chose to base our own work on
SecPAL, a comparatively obscure policy language, instead of the more
popular XACML.

XACML policies are expressed as sets of \emph{rules} that describe
whether a specific action should be allowed or denied. When making a
\emph{request} if a rule's target matches the request then the
appropriate action should be taken. Rules are combined into policies
and may contain many rules which can contradict each other if multiple
ones match a given request. To handle contraditions between rules a
\emph{combining algorithm} may be used to decide how to
proceed. Typical algorithms include:

\begin{description}
  \item[Permit-overrides] where if a single rule gives a permit result then the request is permitted.
  \item[Deny-overrides] where if a single rule gives a deny result then then the request is denied.
  \item[First-applicable] where the rules are given an order of precedence and the first rule in the order that gives a result decides the outcome.
  \item[Only-one-applicable] where only one rule may match, and if there are multiple matches an error is returned.
\end{description}

XACML is a powerful access control and policy language with a published
standard~\cite{oasis_extensible_2013}. It is generic and is used in industry as
a policy language for access control decisions, and there are tools available to
help policy authors write policies in it. Whilst XACML might seem like a
suitable language to model mobile ecosystems, it suffers from various issues.

Readability was a design goal for SecPAL. Its notation is similar to natural
language. Alternate notations based on XML do exist (Becker hints at them in the
SecPAL technical report~\cite{becker_secpal:_2010}); though these are to aid
computerised parsing of SecPAL not human legibility. In contrast, XACML's
default syntax is designed to be in XML by default. XACML policies are verbose and difficult to read.
For example a simple policy that grants a principal, \emph{Alice}, permission to do whatever she liked would be written as:

\begin{lstlisting}
<xacml3:Policy xmlns:xacml3="urn:oasis:names:tc:xacml:3.0:core:schema:wd-17"
  PolicyId="http://axiomatics.com/alfa/identifier/alice.policy"
  RuleCombiningAlgId="urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-overrides"
  Version="1.0">
  <xacml3:Description />
  <xacml3:PolicyDefaults>
    <xacml3:XPathVersion>http://www.w3.org/TR/1999/REC-xpath-19991116</xacml3:XPathVersion>
  </xacml3:PolicyDefaults>
  <xacml3:Target>
    <xacml3:AnyOf>
      <xacml3:AllOf>
        <xacml3:Match MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
          <xacml3:AttributeValue
            DataType="http://www.w3.org/2001/XMLSchema#string">alice</xacml3:AttributeValue>
          <xacml3:AttributeDesignator 
            AttributeId="urn:oasis:names:tc:xacml:1.0:subject:subject-id"
            DataType="http://www.w3.org/2001/XMLSchema#string"
            Category="urn:oasis:names:tc:xacml:1.0:subject-category:access-subject"
            MustBePresent="false"
          />
        </xacml3:Match>
      </xacml3:AllOf>
    </xacml3:AnyOf>
  </xacml3:Target>
  <xacml3:Rule 
      Effect="Permit"
      RuleId="http://axiomatics.com/alfa/identifier/alice.policy.Id_18">
    <xacml3:Description />
    <xacml3:Target />
  </xacml3:Rule>
</xacml3:Policy>
\end{lstlisting}

To help developers write policies alternative notations are available that
compile into XACML's XML notation. ALFA is an alternate notation for
XACML~\cite{oasis_xacml_technical_comitee_abbreviated_2015}. The XACML
developers maintain ALFA, however others notations exist including graphical
languages~\cite{henrik_nergaard_scratch-based_2015}, languages based on
propositional logic~\cite{zhang_synthesising_2004} and answer set
programming~\cite{ramli_xacml_2012}.  The equivalent ALFA policy of the above \emph{allow Alice all} policy would be:

\begin{lstlisting}
namespace alice {
  policy policy {
    target clause Attributes.subjectId == "alice"
    apply permitOverrides
    rule {
      permit
    }
  }
}
\end{lstlisting}

The ALFA policy is far more succinct than the XACML one and shows the
policy's meaning far more clearly than the equivalent XACML version.
There is an (Eclipse based) compiler for ALFA policies into
XACML~\cite{axiomaics_axiomatics_2012}, but there are not tools for
translating XACML to ALFA.  This means that any XACML policies would
need to be rewritten to take advantage of ALFA's syntax, and that any
tweaks made to a XACML policy cannot be trivially reintegrated into
the ALFA version.  Furthermore any analysis of XACMLs semantics cannot
be trivially used to understand the semantics of ALFA.

XACML does not have well-defined semantics. XACML's designers used
natural language to describe the semantics of XACML. This has made the
semantics notoriously difficult to
interpret~\cite{ramli_detecting_2015}. There have been several
attempts to describe XACML's semantics
formally~\cite{ramli_xacml_2012,ramli_logic_2014,bryans_reasoning_2005}. Some
of these translations have only described a subset of XACMLs
syntax~\cite{halpern_using_2008}, others describe older versions of
XACML which are not compatible with the latest language
versions~\cite{ahn_reasoning_2010}, and others have been found to
contain mistakes caused by ambiguities in the XACML
specification~\cite{bruns_access-control_2008,halpern_using_2008}.
All these attempts help us understand XACML, but the lack of a single
standard semantics make it less attractive to extend to a new domain.
The language is also not tied to any particular formal definition of
its semantics.  As the language grows and changes there are no
guarantees that the semantics will remain correct and applicable to
the current version of XACML. In contrast, SecPAL's semantics are
given precisely by Becker~\cite{becker_secpal:_2010}.  SecPAL may not
be as well known as XACML but at least the language definition will
not be changed, and its semantics are set.

Whilst XACML 3.0 does support delegation~\cite{oasis_xacml_2010},
earlier versions do not. The XACML 3.0 standard was published in 2013,
after deciding to start work with SecPAL.  Despite XACML having a
mechanism for delegation its semantics, like the rest of the language,
are poorly defined in natural language.  The standard gives one
example of how delegation in XACML can be used: a company has a
printer and Carol is responsible for saying who can use the printer.
She delegates to Bob who in turn grants Alice the right to use the
printer.  The policy takes four pages and 260 lines of code to
describe~\cite{oasis_xacml_2010}.  In contrast, the equivalent SecPAL
policy is trivial and clear:

\begin{lstlisting}
'company' says 'carol' can-say inf
  Person:X canUse(Printer:P).

'carol' says 'bob' can-say
  Person:X canUse(Printer:P).

'bob' says 'alice' canUse(Printer:P).
\end{lstlisting}

Using ALFA we can also write delegation policies in the style of
XACML.  An example (taken from \cite{axiomatics_going_2016}) might be
a policy for a bank where only the account holder, or the account
holder's guardians can view their account:

\begin{lstlisting}
policy account{ 
  target clause object.objectType == "account"
  apply firstApplicable
  rule viewAccount{ 
    target clause action.actionId == "view"
    condition (user.username == account.owner) ||
      (stringIsIn(stringOneAndOnly(user.username),owner.guardians))
  }
}
\end{lstlisting}

The equivalent in AppPAL would be:

\begin{lstlisting}
'bank' says Person:O canView(Account:A)
if A hasOwner(O).

'bank' says Person:G canView(Account:A)
  if A hasOwner(O),
     O hasGuardian(G).

'bank' says Person:P can-say
  P hasGuardian(Person:G).
\end{lstlisting}

Again we feel the SecPAL version is clearer.  XACML is undoubtably a
capable and powerful as it is used extensively.  However, for modeling
and describing the policies of the mobile ecosystem we favor a
smaller, clearer, and better defined policy language as it allows us
to focus on the policies themselves, rather than trying to comprehend
the policy language used to describe them.

\section{Fine Grained Permission Systems}

If policy languages give us a mechanism to describe trust
relationships and decisions \emph{in general}, fine grained permission
systems are one mechanism by which policy languages are used to
control the behaviour of apps on Android specifically.  In Android to
access certain functionality, for example access to private storage,
apps must request a permission.  Permissions are a coarse usage
control mechanism, and user's ability to control what permissions an
app requested ranged from not installing the app (on versions prior to
Android Marshmallow) to disabling parts of the app (on versions from
Android Marshmallow).  The coarseness of the permissions and their
relative inflexibility led to a line of research into
\emph{fine-grained} permissions systems.  These systems would add
additional controls to permissions and allow greater control about
when they were enforced.

This section looks exclusively at Android as that is where the bulk of
the research has been.  The permission system of iOS allows users to
toggle an app's ability to perform certain actions (access photos,
send notifications) through the settings, and prompts users for a
default policy when the app first attempts to perform the action.
From Android Marshmallow the permissions schemes of iOS and Android
are very similar.

Some of the earliest work on fine-grained permissions systems for
Android starts with Enck~\etal's work on
Kirin~\cite{enck_lightweight_2009}.  Kirin allowed a user to define
what behavior they considered acceptable using a policy language.
Kirin ran on the device to certify apps using static analysis.  If an
app did not conform to the policy the user would be warned and could
uninstall it.  A natural next question is rather than rejecting the
entire app, can you just reject the behaviour you don't like?
Ontang~\etal's SAINT tool~\cite{ongtang_semantically_2012} did just
that for inter-app communication, allowing the user to express a
policy about the circumstances two apps could share data or call
functionality.  Similarly Apex~\cite{nauman_apex:_2010} allowed user's
to specify at install time constraints as to when a permission could
be used.  This allowed them to write policies where an apps ability to
send SMS messages could be denied if the app had already sent a
message within the last hour, for example, or deny access to location
data outside of working hours.  CRePE~\cite{conti_crepe:_2010} took
these ideas further allowing permissions to be denied based on
\emph{context} (for example the user was on a train, or the user was
within Bluetooth range of their computer).

Dr{.}~Android and Mr{.}~Hide~\cite{jeon_dr._2012} was a fine-grained
permission scheme that worked by rewriting apps to use guarded APIs.
Unlike earlier schemes that worked by modifying the Android~OS
Dr{.}~Android decompiles Android apps and removes all permissions.
Sensitive API calls that would normally require permissions were
replaced with IPC calls to Mr{.}~Hide, a privileged Android service
that could enforce a policy with increased controls.  This allowed for
permissions limiting access to certain URLs, contacts, location data,
and phone state and settings.  Modifying the apps not the OS allowed
user's to get better control of app permissions without having to
potentially compromise the integrity of Android by installing a
third-party component with questionable security auditing. The
disadvantage however was that to make the modifications apps had to be
re-signed subtly changing Android's app trust model and moving the
authenticity and integrity checks from the developer to the
Dr{.}~Android tool.  AppGuard~\cite{backes_appguard_2013} worked
similarly to Dr{.}~Android, but allowed for controlled responses when
a permission was denied---essentially ensuring that the app didn't
crash if it didn't get access to the data it expected to.

Similarly to Dr{.}~Android and AppGuard, Aurasium~\cite{xu_aurasium:_2012} works by
modifying API files to use a guarded API.  Unlike Dr{.}~Android it
doesn't use a privileged service to control access to data, rather it
modifies every app to monitor system calls and IPC mechanisms via GOT
hijacking in the Bionic libc.  This allowed for policies that
described how apps should behave at a systemcall level.  This enabled
it to mitigate certain malware techniques, such as executing external
ELF files, or sending premium SMS messages.  Again, like Dr{.}~Android
it requires re-signing apps.  To mitigate this they offered a service
that would re-sign apps with unique keys so for any app there would
only be one Aurasium re-signed version.

SEAndroid was a set of patches to the Android kernel by the US
National~Security~Agency porting the SELinux discretionary access
control to Android~\cite{smalley_security_2013}.  The permissions
system in Android had been implemented by using the Linux groups
mechanisms.  When an app launched, the process would be created by
forking a copy of the privileged \emph{zygote} Dalvik virtual machine
process\footnote{A \emph{zygote} would run in the background permanently
semi-initialised to allow apps to start quickly.}, which would then
drop privileges and set gids based on the permissions the app declared.

This implementation was problematic as it inherrited many of the
problems with Linux's discretionary access control model, had no
centralised policy document describing how permissions were used (the
policy was expressed by the permissions of the filesystem), but also
meant that the sandboxing mechanisms relied upon having this
privileged zygote running (as well as potentially other services).

SEAndroid ported the basic SELinux security mechanisms to Android,
provided a default policy that described how the permissions and
sandboxing systems should work under a mandatory access control
scheme, and integrated it with the zygote system for starting
apps.\footnote{SELinux policies are usually applied on
\texttt{exec}-ing a process, not the \texttt{clone} used by the
zygote.}

Whilst SEAndroid did not implement a fine-grained permissions system
by itself, it was merged into Android and would replace the original
permissions system.  By Android Marshmallow it was fully enabled, and
allowed an app's permissions to be granted or denied by the user as
the permissions system was far more flexible than the original DAC
implementation.

%% I'm not sure about this
%\section{Static analysis tools}
%
%There have been many static tools developed that can infer complex
%properties about
%apps~\cite{felt_android_2011,song_integrated_2016,antonin_carette_investigating_2017,schmidt_static_2009,enck_taintdroid:_2014}.
%Leveraging these tools in a policy language lets us make statements about the
%properties they can infer, without having to reimplement the functionality.
%Despite the power of these tools it is not obvious how they should integrate
%with the policies surrounding the mobile ecosystem. Running and configuring each
%It isn't clear when each tool should run, or how to configure them to enforce a
%policy rule. By incorporating these tools into a policy language, such as
%SecPAL, we can act as a glue-layer between the policies of the mobile ecosystem
%and the research into the properties of code.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ch7.tex"
%%% End:
