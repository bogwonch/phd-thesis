    \documentclass[thesis.tex]{subfiles}
    \begin{document}
    \chapter{Related Work}
    \label{chap:related-work}

    %\section{Android and Mobile OSs}\label{android}
    %
    %Android is a mobile operating system developed, primarily, by Google. It is by
    %far the most popular mobile operating system in use being installed on around
    %83\% of all mobile
    %handsets\footnote{\url{http://www.idc.com/prodserv/smartphone-os-market-share.jsp}}
    %with Apple's iOS being its only major competitor (Windows Phone, Blackberry OS
    %and other mobile operating systems account for only 3\% of the marketshare in
    %2015).
    %
    %Despite the dominance of Android its ecosystem is rather fragmented. As shown in
    %\autoref{fig:android-versions}, in June 2016 only 10\% of devices used the
%latest version of Android, with around 5\% of devices still using a version
%released five years prior. The range of different Android versions is often
%blamed on the device manufacturers being unwilling to update their devices.
%Since the core of Android is open source this has lead to third parties (such as the now-depreciated
%CyanogenMod\footnote{\url{http://www.cyanogenmod.org}} and LineageOS~\cite{lineageos_lineageos_2017}) have started developed
%custom firmware for Android devices to allow older devices to be upgraded
%independently of their manufacturers.
%
%\begin{figure}
%\centering
%\includegraphics[width=\linewidth]{figures/android-versions.pdf}
%\caption[Historical Android version's distribution.]{Historical Android
%  version's distribution~\cite{erikrespo_android_2017}.}
%\label{fig:android-versions}
%\end{figure}
%
%When building an Android device the manufacturers are also able to make
%modifications to the Android firmware. This can be done to support any custom
%hardware their device may have, add any additional software or apps, or provide
%a custom look or theme to atheir device. Again this creates more variety in the
%ecosystem, with few guarantees that any two devices may contain similar features
%or hardware. In fact since the core of the Android is the Linux kernel (albeit
%without the Linux Standard Base\footnote{The \emph{Linux Standard Base} is a
%  specification produced by the Linux foundation that describes what a stardard
%  Linux system should contain and how it should be organised. Android uses its own
%  system which differs most noticably by the different filesystem structures and
%  the use of user IDs to separate apps rather than users~\cite{linux_foundation_lsb_2015}.}, and with additional
%patches) it can be ported to other architectures (such as X86 and MIPS), and
%used in other devices (such as set-top boxes and TVs, watches, and cars) with
%relative ease.
%
%To give developers a somewhat stable base to develop for Google developed the
%\ac{CTS}\footnote{\url{https://source.android.com/compatibility/cts/index.html}},
%and \ac{CDD}\footnote{\url{https://source.android.com/compatibility/android-cdd.html}}.
%The \ac{CTS} is a series of unit tests that check basic Android functionality and
%behavior. The \ac{CDD} is a document that describes what hardware an Android device
%should have and how the device and it's software should be built. If a device
%manufacturer wishes their device to run Google's Play Store (the largest Android
%app marketplace), then they are required to show they can pass the \ac{CTS} and are
%in compliance with the \ac{CDD}.

\section{Authorization Logic and Fine Grained Permission Systems}
\label{sec:authorization-logic}

Our work on AppPAL extends Becker's work on SecPAL to support the
policies surrounding the mobile ecosystem.  This work is, of course,
not done in isolation but part of a larger work into policy languages.
In this section we review some of the many policy languages AppPAL
grew from and was inspired by, as well as the fine-grained permission
schemes that have become an important mechanism for enforcing policies
on Android devices and have added to work on policy languages
themselves.


\subsection{Policy Languages}
%\subsection{PolicyMaker}

PolicyMaker~\cite{blaze_decentralized_1996} was created to give a
language for permitted actions.  It grew out of the logics of
authentication of Wobber, Abadi, Burrows and Lampson~\cite{wobber_authentication_1994,abadi_calculus_1991}; as well as a
dissatisfaction with identification mechanisms.  X.509 and PGP
certificates had given a mechanism for identifying users; at the time
however, they did not give any means to link the users to what users
were allowed to do.

To describe the authorizations trust information is contained within
assertions.  A collection of assertions form the policy.  An assertion
has a source (either the local policy document or a public key). The
source \emph{asserts} that a key (or more complex arrangements such as
three of four keys) is permitted to perform any action that matches
the \emph{filter}.  The filter itself is essentially an arbitrary
program that can decide if an action is permitted.
Blaze~\etal~provide examples using regular expressions and a reduced
version of AWK~\cite{aho_awk-pattern_1979} they call \emph{AWKWARD},
though they note that any programming language could be used.  The
collection of these authorizations on a machine forms the policy for
the device which can be queried by a PolicyMaker key \emph{requesting}
a given action.

Blaze~\etal~give an example of this scheme being used as part of an
email server.  A user, Alice, identified by key \texttt{0x12345678} is
permitted to send emails with the from header set to Alice and the
organisation set to Bob Labs.

A PolicyMaker instance is installed on a server and allowed to receive queries and give answers.
The policy is installed on the server as follows:

\begin{lstlisting}
policy ASSERTS
  pgp:'0x12345678'
  WHERE PREDICATE=regexp:'(From: Alice) &&
    (Organization: Bob Labs)';
\end{lstlisting}

When Alice tries to send an email using a PolicyMaker enhanced SMTP
client she signs and sends her message using her key.  The mailserver
checks the signature and queries the policy server with her message:

\begin{lstlisting}
  pgp:'0x12345678'
  REQUESTS  'From: Alice
             Organization: Bob Labs

             Hello World!';
\end{lstlisting}

If Alice's request is accepted then the SMTP server will send the
message.  If it doesn't match the policy then it won't.

PolicyMaker was used as the basis for the KeyNote Trust Management
System~\cite{blaze_role_1999,blaze_keynote:_1998} which simplified the
filter languages from any arbitrary language to a purpose built one
based on C that always returned a boolean answer, allowed the policy
server to do the signature verification instead of the querying
application, and tweaked the syntax for readability.  It was designed
to trade some of the generality of PolicyMaker for a more realistic
scenario using public-key infrastructure.  The equivalent policy for KeyNote could be written:

\begin{lstlisting}
Authorizer: "POLICY"
Licensees: "RSA:abc123"

KeyNote-Version: "2"
Local-Constants: Alice="RSA:12345678" 
Authorizer: "RSA:abc123"
Conditions: (app_domain == "RFC822-EMAIL") &&
    (name="Alice") &&
    (organization="Bob Labs");
\end{lstlisting}

Checking whether a PolicyMaker or KeyNote policy is satisfied is
NP-hard~\cite{blaze_compliance_1998}.  It is not tractable as checking
PolicyMaker assertions can involve arbitrary programs written in
Turing complete languages.  Deciding whether a program will stop when
given an arbitrary input is analogous to the halting problem.  So in
general it is not known whether a PolicyMaker program which takes an
arbitrary request and an unconstrained set of checking functions will
terminate: it is undecidable.  Blaze~\etal{} give
some restrictions that guarantee polynomial time checking: a function
must be authentic (not fake another functions result), monotonic, and
run in polynomial time for all inputs pertinent to a request.  This
reduced the expressiveness however.

Another weakness of these languages is that they cannot express
general relationships as the subjects of the policy cannot be a
variable.  You cannot have, for example, a policy where the subject is
a set of users.  The example policy could not be written as
\emph{anyone working in R\&D can send email from Bob Labs.}  This
restriction made the languages less expressive than they might
otherwise have been.

%\subsection{SPKI/SDSI}

In contrast to PolicyMaker SPKI/SDSI~\cite{ellison_spki_1999} is
designed to associate keys with roles.  A user, Alice with key~$K_A$,
can present a certificate that says she can act as a \emph{Bob Labs
employee} (authorized by Bob with key~$K_B$) for one~year.

\begin{equation*}
  (K_A,~\text{\tt BobLabsEmployee},~K_B,~1~\text{year})
\end{equation*}

Bob can also create authorization certificates to permit his employees
to send emails, and can optionally delegate the decision further.

\begin{equation*}
 (K_B,~(K_B,~\text{\tt BobLabsEmployee}),~\bot,~\text{\ttfamily send\_email},~1~\text{year})
\end{equation*}

Where PolicyMaker let an administrator check if a specific action was
permitted by a specific user, SPKI/SDSI lets administrators associate
users with roles and roles with tasks.  The SPKI/SDSI version of the
email sending policy doesn't specify that all emails sent by Employees
must have a field listing the lab as the sending organization; that
part of the policy must be implemented by whatever implemented the
\texttt{send\_email} functionality.  One of the large advantages of
SPKI/SDSI is that it allows a higher-level view of the policy by
associating groups of users with a role, and roles with allowed
actions.

A weakness of SPKI/SDSI however was that the language was not designed
with formal semantics.  This meant that it was not possible to define
precisely what promises the language gave or how to extend it safely
or even exactly what it does.  All these things must be inferred from
RFC 2693 which loosely defined it~\cite{ellison_spki_1999}. There were
several later attempts to fit a semantics to the
language~\cite{joseph_y._halpern_logic_1999,abadi_sdsis_1998,howell_formal_2000},
however not all covered every aspect of SPKI/SDSIs features.

The focus on roles leads to the RT family of
languages~\cite{ninghui_li_design_2002}, which associates policy
decisions with roles similar to how \ac{RBAC} systems associate access
decisions to the roles a user holds.  Policies are expressed as Horn
clauses.  A rule such as:

\begin{lstlisting}[language=prolog]
Bob.employee :- alice.
Bob.employee.sendEmail :- Bob.employee.
\end{lstlisting}

Should be read as \emph{Bob says Alice is an employee.  Bob says an
employee can send emails if they are an employee.}  Li~\etal{}
describe many different variants of RT each with increasing numbers of
features.  The most basic variant is
\RT{0}{}~\cite{li_distributed_2003}, but \RT{1}{} adds support for
parameterized roles, and \RT{2}{} adds logical objects on top of the
roles.  As well as these variants, the RT family of languages have
support for optional feature sets: \RT{}{T} allows for policies with
thresholds (i.e. Alice can send an email if two out of three of the
board members approve it), \RT{}{C} adds constraints, and \RT{}{D}
adds delegation~\cite{ninghui_li_design_2002}.

Unlike PolicyMaker, the RT family of languages is tractable, they can
guarantee that a query will be answered soundly in polynomial time
with respect to the size of the policy.  To give this guarantee trust
languages some trust languages such as
Binder~\cite{detreville_binder_2002} and
Delegation~Logic~\cite{li_delegation_2003,li_practically_2000} had
shown that they could be reduced to Datalog, a database language with
known complexity guarantees and fast evaluation based on Prolog.  One
limitation of Datalog is that it cannot describe structured data: for
example consider an administrator who wishes to write a policy rule
that says Alice can send email between 9am and 5pm.  We can imagine in
the policy rule having some function to fetch the time and another to
compare whether it is within that range.  In Datalog we cannot
trivially write this function and instead have to enumerate each
possible time in that domain and state whether it is within that
period. For example:

\begin{lstlisting}
  between_9_to_5(9:00).
  between_9_to_5(9:01).
  between_9_to_5(9:02).
  ...
  between_9_to_5(16:59).
  between_9_to_5(17:00).
\end{lstlisting}

This is obviously undesirable: we would need to add almost 500
statements to the knowledge base for resolution of the time to
minutes, and tens of thousands if we need the time accurate to
seconds.  More generally whenever there is data that has structure
such as file paths, times or numeric intervals; Datalog databases can
become large and start to become intractable.

To solve this problem Li~\etal{}~proposed a modified version of
Datalog called Datalog\textsuperscript{C}~\cite{li_datalog_2003},
based on Constraint
Datalog~\cite{revesz_constraint_1995,revesz_safe_1998}, that better
supported constraints and kept Datalog's tractability, with a focus on
the constraints typical to a policy languages instead of those for
database programming.

Datalog\textsuperscript{C} has also been used as a foundation for many
other policy languages including SecPAL based
languages~\cite{aziz_secpal4dsa:_2011,becker_secpal:_2010,becker_framework_2009,hallett_apppal_2016}
and DKAL~\cite{gurevich_dkal:_2008}, as well as
Cassandra~\cite{becker_cassandra:_2004}.

Cassandra is a trust management language used to model large systems,
in particular the NHS Spine: a system designed to enable healthcare
workers to share patient
data~\cite{becker_cassandra:_2004,becker_cassandra:_2004-1}.  The
language is similar to the RT family, sharing both a backend and some
syntax, however Cassandra focuses on roles rather than general access
control mechanisms.  Rather than having principals hold or be given
roles, principals \emph{activate} roles when they need to act in that
capacity.  This allows a single principal to hold different roles with
different access capabilities at different times and at different
locations.  For example a \emph{hospital} \emph{admin} allows a
\emph{clinician} access to a \emph{patient}'s records if they
currently hold the role of \emph{Clinician} at the hospital, and can
\emph{activate} the role of \emph{Treating Clinician} for that patient
at this \emph{hospital}.

\begin{lstlisting}
hospital@admin.permits(clinician, Read-Records(patient)) <-
  hospital@hasActivated(clinician, Clinician(hospital)),
  hospital@canActivate(clinician, TreatingClinician(hospital, patient))
\end{lstlisting}

Cassandra allows for powerful control of different roles, and enables
delegation by allowing third-parties to activate and deactivate roles
on others.  It was applied successfully to modelling access control
with electronic healthcare records.

The DKAL family of
languages~\cite{jeannin_dkal*:_2013,gurevich_dkal:_2008,yuri_gurevich_dkal2---simplified_2009}
grew from SecPAL as a policy language for a distributed system's
interacting agents~\cite{blass_introduction_2012}.  Assertions are
communicated as signed statements called \emph{infons} between
principals.  For example Alice might wish to recommend Bob an app.
Alice, therefore, sends to Bob the infon:

\begin{lstlisting}
alice said com.rovio.angrybirds is a good app.
\end{lstlisting}

Bob is free to do with this information as he wishes.  He may be
willing to accept app recommendations from anyone and may have a rule
to learn that fact:

\begin{lstlisting}
with M: String, P: Principal
  upon
    P said M is a good app
  do
    learn P said M is a good app
\end{lstlisting}

DKAL2~\cite{yuri_gurevich_dkal2---simplified_2009} simplified the
language removing the constructs for roles that had been taken from
SecPAL but which they could not find a use for.  They also added
support for sending infons if the recipient has completed an action:
for example only sending an app recommendation if the recipient has
asked for it.
DKAL\textsuperscript{$\star$}~\cite{jeannin_dkal*:_2013} took these
ideas further and showed how DKAL programs that described how infons
should be shared could be used as executable protocols.

\subsubsection{XACML}

XACML is a standardised policy language~\cite{oasis_extensible_2013}
that can be extended to fit many scenarios. It is an attribute based
policy language, but can also describe role-based policies; and has
industrial support from \emph{Oracle}.  It is worthy of special
attention as it has become an extremely popular policy language from
both an industrial and academic standpoint.  As such it is important
to summarize and briefly describe why we chose to base our own work on
SecPAL, a comparatively obscure policy language, instead of the more
popular XACML.

XACML policies are expressed as sets of \emph{rules} that describe
whether a specific action should be allowed or denied. When making a
\emph{request} if a rule's target matches the request then the
appropriate action should be taken. Rules are combined into policies
and may contain many rules which can contradict each other if multiple
ones match a given request. To handle contraditions between rules a
\emph{combining algorithm} may be used to decide how to
proceed. Typical algorithms include:

\begin{description}
  \item[Permit-overrides] where if a single rule gives a permit result then the request is permitted.
  \item[Deny-overrides] where if a single rule gives a deny result then then the request is denied.
  \item[First-applicable] where the rules are given an order of precedence and the first rule in the order that gives a result decides the outcome.
  \item[Only-one-applicable] where only one rule may match, and if there are multiple matches an error is returned.
\end{description}

XACML is a powerful access control and policy language with a published
standard~\cite{oasis_extensible_2013}. It is generic and is used in industry as
a policy language for access control decisions, and there are tools available to
help policy authors write policies in it. Whilst XACML might seem like a
suitable language to model mobile ecosystems, it suffers from various issues.

Readability was a design goal for SecPAL. Its notation is similar to natural
language. Alternate notations based on XML do exist (Becker hints at them in the
SecPAL technical report~\cite{becker_secpal:_2010}); though these are to aid
computerised parsing of SecPAL not human legibility. In contrast, XACML's
default syntax is designed to be in XML by default. XACML policies are verbose and difficult to read.
For example a simple policy that grants a principal, \emph{Alice}, permission to do whatever she liked would be written as:

\begin{lstlisting}
<xacml3:Policy xmlns:xacml3="urn:oasis:names:tc:xacml:3.0:core:schema:wd-17"
  PolicyId="http://axiomatics.com/alfa/identifier/alice.policy"
  RuleCombiningAlgId="urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-overrides"
  Version="1.0">
  <xacml3:Description />
  <xacml3:PolicyDefaults>
    <xacml3:XPathVersion>http://www.w3.org/TR/1999/REC-xpath-19991116</xacml3:XPathVersion>
  </xacml3:PolicyDefaults>
  <xacml3:Target>
    <xacml3:AnyOf>
      <xacml3:AllOf>
        <xacml3:Match MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
          <xacml3:AttributeValue
            DataType="http://www.w3.org/2001/XMLSchema#string">alice</xacml3:AttributeValue>
          <xacml3:AttributeDesignator 
            AttributeId="urn:oasis:names:tc:xacml:1.0:subject:subject-id"
            DataType="http://www.w3.org/2001/XMLSchema#string"
            Category="urn:oasis:names:tc:xacml:1.0:subject-category:access-subject"
            MustBePresent="false"
          />
        </xacml3:Match>
      </xacml3:AllOf>
    </xacml3:AnyOf>
  </xacml3:Target>
  <xacml3:Rule 
      Effect="Permit"
      RuleId="http://axiomatics.com/alfa/identifier/alice.policy.Id_18">
    <xacml3:Description />
    <xacml3:Target />
  </xacml3:Rule>
</xacml3:Policy>
\end{lstlisting}

To help developers write policies alternative notations are available that
compile into XACML's XML notation. ALFA is an alternate notation for
XACML~\cite{oasis_xacml_technical_comitee_abbreviated_2015}. The XACML
developers maintain ALFA, however others notations exist including graphical
languages~\cite{henrik_nergaard_scratch-based_2015}, languages based on
propositional logic~\cite{zhang_synthesising_2004} and answer set
programming~\cite{ramli_xacml_2012}.  The equivalent ALFA policy of the above \emph{allow Alice all} policy would be:

\begin{lstlisting}
namespace alice {
  policy policy {
    target clause Attributes.subjectId == "alice"
    apply permitOverrides
    rule {
      permit
    }
  }
}
\end{lstlisting}

The ALFA policy is far more succinct than the XACML one and shows the
policy's meaning far more clearly than the equivalent XACML version.
There is an (Eclipse based) compiler for ALFA policies into
XACML~\cite{axiomaics_axiomatics_2012}, but there are not tools for
translating XACML to ALFA.  This means that any XACML policies would
need to be rewritten to take advantage of ALFA's syntax, and that any
tweaks made to a XACML policy cannot be trivially reintegrated into
the ALFA version.  Furthermore any analysis of XACMLs semantics cannot
be trivially used to understand the semantics of ALFA.

XACML does not have well-defined semantics. XACML's designers used
natural language to describe the semantics of XACML. This has made the
semantics notoriously difficult to
interpret~\cite{ramli_detecting_2015}. There have been several
attempts to describe XACML's semantics
formally~\cite{ramli_xacml_2012,ramli_logic_2014,bryans_reasoning_2005}. Some
of these translations have only described a subset of XACMLs
syntax~\cite{halpern_using_2008}, others describe older versions of
XACML which are not compatible with the latest language
versions~\cite{ahn_reasoning_2010}, and others have been found to
contain mistakes caused by ambiguities in the XACML
specification~\cite{bruns_access-control_2008,halpern_using_2008}.
All these attempts help us understand XACML, but the lack of a single
standard semantics make it less attractive to extend to a new domain.
The language is also not tied to any particular formal definition of
its semantics.  As the language grows and changes there are no
guarantees that the semantics will remain correct and applicable to
the current version of XACML. In contrast, SecPAL's semantics are
given precisely by Becker~\cite{becker_secpal:_2010}.  SecPAL may not
be as well known as XACML but at least the language definition will
not be changed, and its semantics are set.

Whilst XACML 3.0 does support delegation~\cite{oasis_xacml_2010},
earlier versions do not. The XACML 3.0 standard was published in 2013,
after deciding to start work with SecPAL.  Despite XACML having a
mechanism for delegation its semantics, like the rest of the language,
are poorly defined in natural language.  The standard gives one
example of how delegation in XACML can be used: a company has a
printer and Carol is responsible for saying who can use the printer.
She delegates to Bob who in turn grants Alice the right to use the
printer.  The policy takes four pages and 260 lines of code to
describe~\cite{oasis_xacml_2010}.  In contrast, the equivalent SecPAL
policy is trivial and clear:

\begin{lstlisting}
'company' says 'carol' can-say inf
  Person:X canUse(Printer:P).

'carol' says 'bob' can-say
  Person:X canUse(Printer:P).

'bob' says 'alice' canUse(Printer:P).
\end{lstlisting}

Using ALFA we can also write delegation policies in the style of
XACML.  An example (taken from \cite{axiomatics_going_2016}) might be
a policy for a bank where only the account holder, or the account
holder's guardians can view their account:

\begin{lstlisting}
policy account{ 
  target clause object.objectType == "account"
  apply firstApplicable
  rule viewAccount{ 
    target clause action.actionId == "view"
    condition (user.username == account.owner) ||
      (stringIsIn(stringOneAndOnly(user.username),owner.guardians))
  }
}
\end{lstlisting}

The equivalent in AppPAL would be:

\begin{lstlisting}
'bank' says Person:O canView(Account:A)
if A hasOwner(O).

'bank' says Person:G canView(Account:A)
  if A hasOwner(O),
     O hasGuardian(G).

'bank' says Person:P can-say
  P hasGuardian(Person:G).
\end{lstlisting}

Again we feel the SecPAL version is clearer.  XACML is undoubtably a
capable and powerful as it is used extensively.  However, for modeling
and describing the policies of the mobile ecosystem we favor a
smaller, clearer, and better defined policy language as it allows us
to focus on the policies themselves, rather than trying to comprehend
the policy language used to describe them.

\subsection{Fine Grained Permission Systems}

If policy languages give us a mechanism to describe trust
relationships and decisions \emph{in general}, fine grained permission
systems are one mechanism by which policy languages are used to
control the behaviour of apps on Android specifically.  In Android to
access certain functionality, for example access to private storage,
apps must request a permission.  Permissions are a coarse usage
control mechanism, and user's ability to control what permissions an
app requested ranged from not installing the app (on versions prior to
Android Marshmallow) to disabling parts of the app (on versions from
Android Marshmallow).  The coarseness of the permissions and their
relative inflexibility led to a line of research into
\emph{fine-grained} permissions systems.  These systems would add
additional controls to permissions and allow greater control about
when they were enforced.

This section looks exclusively at Android as that is where the bulk of
the research has been.  The permission system of iOS allows users to
toggle an app's ability to perform certain actions (access photos,
send notifications) through the settings, and prompts users for a
default policy when the app first attempts to perform the action.
From Android Marshmallow the permissions schemes of iOS and Android
are very similar.

Some of the earliest work on fine-grained permissions systems for
Android starts with Enck~\etal's work on
Kirin~\cite{enck_lightweight_2009}.  Kirin allowed a user to define
what behavior they considered acceptable using a policy language.
Kirin ran on the device to certify apps using static analysis.  If an
app did not conform to the policy the user would be warned and could
uninstall it.  A natural next question is rather than rejecting the
entire app, can you just reject the behaviour you don't like?
Ontang~\etal's SAINT tool~\cite{ongtang_semantically_2012} did just
that for inter-app communication, allowing the user to express a
policy about the circumstances two apps could share data or call
functionality.  Similarly Apex~\cite{nauman_apex:_2010} allowed user's
to specify at install time constraints as to when a permission could
be used.  This allowed them to write policies where an apps ability to
send SMS messages could be denied if the app had already sent a
message within the last hour, for example, or deny access to location
data outside of working hours.  CRePE~\cite{conti_crepe:_2010} took
these ideas further allowing permissions to be denied based on
\emph{context} (for example the user was on a train, or the user was
within Bluetooth range of their computer).

Dr{.}~Android and Mr{.}~Hide~\cite{jeon_dr._2012} was a fine-grained
permission scheme that worked by rewriting apps to use guarded APIs.
Unlike earlier schemes that worked by modifying the Android~OS
Dr{.}~Android decompiles Android apps and removes all permissions.
Sensitive API calls that would normally require permissions were
replaced with IPC calls to Mr{.}~Hide, a privileged Android service
that could enforce a policy with increased controls.  This allowed for
permissions limiting access to certain URLs, contacts, location data,
and phone state and settings.  Modifying the apps not the OS allowed
user's to get better control of app permissions without having to
potentially compromise the integrity of Android by installing a
third-party component with questionable security auditing. The
disadvantage however was that to make the modifications apps had to be
re-signed subtly changing Android's app trust model and moving the
authenticity and integrity checks from the developer to the
Dr{.}~Android tool.  AppGuard~\cite{backes_appguard_2013} worked
similarly to Dr{.}~Android, but allowed for controlled responses when
a permission was denied---essentially ensuring that the app didn't
crash if it didn't get access to the data it expected to.

Similarly to Dr{.}~Android and AppGuard, Aurasium~\cite{xu_aurasium:_2012} works by
modifying API files to use a guarded API.  Unlike Dr{.}~Android it
doesn't use a privileged service to control access to data, rather it
modifies every app to monitor system calls and IPC mechanisms via GOT
hijacking in the Bionic libc.  This allowed for policies that
described how apps should behave at a systemcall level.  This enabled
it to mitigate certain malware techniques, such as executing external
ELF files, or sending premium SMS messages.  Again, like Dr{.}~Android
it requires re-signing apps.  To mitigate this they offered a service
that would re-sign apps with unique keys so for any app there would
only be one Aurasium re-signed version.

SEAndroid was a set of patches to the Android kernel by the US
National~Security~Agency porting the SELinux discretionary access
control to Android~\cite{smalley_security_2013}.  The permissions
system in Android had been implemented by using the Linux groups
mechanisms.  When an app launched, the process would be created by
forking a copy of the privileged \emph{zygote} Dalvik virtual machine
process\footnote{A \emph{zygote} would run in the background permanently
semi-initialised to allow apps to start quickly.}, which would then
drop privileges and set gids based on the permissions the app declared.

This implementation was problematic as it inherrited many of the
problems with Linux's discretionary access control model, had no
centralised policy document describing how permissions were used (the
policy was expressed by the permissions of the filesystem), but also
meant that the sandboxing mechanisms relied upon having this
privileged zygote running (as well as potentially other services).

SEAndroid ported the basic SELinux security mechanisms to Android,
provided a default policy that described how the permissions and
sandboxing systems should work under a mandatory access control
scheme, and integrated it with the zygote system for starting
apps.\footnote{SELinux policies are usually applied on
\texttt{exec}-ing a process, not the \texttt{clone} used by the
zygote.}

Whilst SEAndroid did not implement a fine-grained permissions system
by itself, it was merged into Android and would replace the original
permissions system.  By Android Marshmallow it was fully enabled, and
allowed an app's permissions to be granted or denied by the user as
the permissions system was far more flexible than the original DAC
implementation.

%% I'm not sure about this
%\section{Static analysis tools}
%
%There have been many static tools developed that can infer complex
%properties about
%apps~\cite{felt_android_2011,song_integrated_2016,antonin_carette_investigating_2017,schmidt_static_2009,enck_taintdroid:_2014}.
%Leveraging these tools in a policy language lets us make statements about the
%properties they can infer, without having to reimplement the functionality.
%Despite the power of these tools it is not obvious how they should integrate
%with the policies surrounding the mobile ecosystem. Running and configuring each
%It isn't clear when each tool should run, or how to configure them to enforce a
%policy rule. By incorporating these tools into a policy language, such as
%SecPAL, we can act as a glue-layer between the policies of the mobile ecosystem
%and the research into the properties of code.

\section{Datalog}
\label{ssec:datalog}

Datalog is used in the implementation of several authorization
logics~\cite{detreville_binder_2002,li_distributed_2003,becker_secpal:_2010}. A brief explanation of the languageand its variants is given for some context as to how these languages
can be implemented and the limitations the languages inherit from
Datalog.

Datalog is a database language. It was created from a simplification
of general logic programming. The language is based on first order
logic; evaluation of Datalog is both sound and complete (under the
\ac{CWA}). Datalog is used as the basis for several of the
authorization logics including SecPAL. We will review several
evaluation strategies used for querying Datalog knowledge bases as
most common method (bottom-up) is not particularly suitable for
authorization logic application

Datalog programs are presented as series of Horn clauses in the same
way as Prolog. There are additional restrictions, however: all
variables in the head of a clause must be present in the body, and no
parameter can be a nested predicate.  Datalog programs are split into
two sets. The \ac{EDB} has all ground (containing no free variables)
facts. The \ac{IDB} contains rules for deriving more facts.

\subsection{Evaluation Strategies}

The bottom-up or Gauss-Seidel method is a simple evaluation
strategy~\cite{ceri_what_1989}. Given a Datalog program we try every
constant with every rule from the IDB. When a rule is found to be true
we add it to the set of facts. Repeat until a fixed point (or the
required fact) is known. If a queried fact is still unknown when the
search terminates then it is false; as Datalog assumes the CWA. The
strategy is complete and will always terminate.  Querying the database
is fast once all facts have been inferred and large joins are quick.
This strategy ends up computing all known facts. It is less useful
when only a subset are interesting. The magic
sets~\cite{bancilhon_magic_1986} rewriting rule avoids this
problem. Interesting constants are marked as magic. The knowledge base
is a graph: nodes related to a magic one are also magic. Rules in the
IDB are rewritten to check constants used in the inference are also be
magic. This cuts down on irrelevant results: anything that isn't
interesting will not be in the magic set.

The SLD-resolution algorithm works top down. It starts with a goal and
then constructs a proof tree. Transitions are applications of rules
from the IDB. Nodes are either facts (the leaves) or further
branches. If there is a subtree from the query node to true facts then
it is true. Prolog uses this strategy. Its memory efficient as it
searches the tree in a depth-first manner. Breadth-first and other
tree traversal searches are also possible as are parallel
strategies. The top-down strategy is less commonly used with Datalog
programs. Saving previous search results (called tabling) is often
used with this strategy to speed queries.

The SLD resolution may not terminate if there are a set of rules that
set up an infinite loop (for instance the rule \lstinline!a(X) :- a(X).!).
Because Prolog has an infinite number of constants (integers
for example) it is also possible to construct queries which return an
infinite number of answers. Datalog does not suffer from this as it's
programs must contain all known constants because of the \ac{CWA} (and
therefore there are a finite number of them).


\subsection{Datalog Variants}

Datalog does not support negation. It is not possible to write
rules which depend on false facts.  This is inconvenient as it is
natural to write rules which rely upon a negative result: for example
an app is safe to run if it is not malware.  Whilst this extension to Datalog is
not strictly required (the \ac{CWA} can be used) it makes programs clearer.

A version of Datalog with negation called
\emph{Datalog$^\lnot$}~\cite{ceri_what_1989} is made by allowing negation in clause
bodies. Two sets of known facts are defined: those that are true and those that
are false.  When deciding if a fact is satisfied by a Datalog program if the
fact is not negated then it must be inferable by the rules of the program; if
the fact is negated then it must not be satisfiable.  

In unmodified Datalog if the bottom-up strategy
is used all possible facts are inferred. These facts form a single, minimal
model of the Datalog program.  In Datalog$^\lnot$ the program \texttt{safe(game)
:- $\mathsf\lnot$ malware(game).} has two minimal models that are inconsistent
with each other: \code{safe(game)} and \code{malware(game)}.  This can make
analysis problematic as the \ac{CWA} is broken. A further variant called
\emph{Stratified Datalog$^\lnot$} avoids this by further restricting what can be
negated and defining an evaluation order~\cite{minker_foundations_2014}.

Constraint Datalog (Datalog$^C$~\cite{li_datalog_2003}) is based
on constraint logic programming.  Constraint logic programming allows
relationships to be defined with general relationships (ordering by time
for example)\footnote{Full logic programming languages like Prolog often
support these relations. Datalog, however, does not as it would require all
possible times to be named, and described in order to each other.} rather than with just the pre-defined predicates.  Being able to
define relations in terms of general relations is convenient for
authorization logics as it lets things be defined in terms of time or
other general (and infinite) concepts. 
Expressing these relations in Datalog is hard, as described earlier.

While some constraints applied to domains are tractable (such as
trees, ordering and discrete domains) Li~\etal{}~could not show
all were.  Policy languages that use constraint Datalog often apply
additional restrictions on how constraints can be used.  Variable independence
conditions~\cite{chomicki_variable_2003} have been suggested as a \emph{middle-ground}
as they can simplify the query evaluation while still keeping the extra
expressiveness Datalog with constraints allows.

Probabilistic Datalog
(Datalog\textsubscript{P}~\cite{fuhr_probabilistic_1995}) is a variant
of Datalog for handling uncertain knowledge.  It differs from regular
Datalog in that ground facts can be tagged with a probability that
they are true.  If multiple proofs could be found to support an
inference from a rule then the probabilities would be combined to
account for the multiple proofs and adjust the probability
appropriately. This enabled Datalog\textsubscript{P} to reason about
uncertain data, but was somewhat limited as rules themselves could not
also have a probability associated with them.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ch7.tex"
%%% End:
