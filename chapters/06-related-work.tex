\documentclass[thesis.tex]{subfiles}
\begin{document}
\chapter{Related Work}
\label{chap:related-work}

\section{Android and Mobile OSs}\label{android}
\todo{PUT IN THE DIFFERENCES BETWEEN THE SYSTEMS EXPRESSED IN APPPAL HERE AND MOVE IT TO CH4 WHEN DAVID TELLS YOU TO}

Android is a mobile operating system developed, primarily, by Google. It is by
far the most popular mobile operating system in use being installed on around
83\% of all mobile
handsets\footnote{\url{http://www.idc.com/prodserv/smartphone-os-market-share.jsp}}
with Apple's iOS being its only major competitor (Windows Phone, Blackberry OS
and other mobile operating systems account for only 3\% of the marketshare in
2015).

Despite the dominance of Android its ecosystem is rather fragmented. As shown in
Figure \url{fig:android-versions}, in June 2016 only 10\% of devices used the
latest version of Android, with around 5\% of devices still using a version
released five years prior. The range of different Android versions is often
blamed on the device manufacturers being unwilling to update their devices.
Since the core of Android is open source this has lead to third parties (such as the now-depreciated
CyanogenMod\footnote{\url{http://www.cyanogenmod.org}} and LineageOS~\cite{lineageos_lineageos_2017}) have started developed
custom firmware for Android devices to allow older devices to be upgraded
independently of their manufacturers.

\begin{figure*}
\centering
\includegraphics[width=\linewidth]{figures/android-versions.pdf}
\caption[Historical Android version's distribution.]{Historical Android
  version's distribution~\cite{erikrespo_android_2017}.}
\end{figure*}

When building an Android device the manufacturers are also able to make
modifications to the Android firmware. This can be done to support any custom
hardware their device may have, add any additional software or apps, or provide
a custom look or theme to atheir device. Again this creates more variety in the
ecosystem, with few guarantees that any two devices may contain similar features
or hardware. In fact since the core of the Android is the Linux kernel (albeit
without the Linux Standard Base\footnote{The \emph{Linux Standard Base} is a
  specification produced by the Linux foundation that describes what a stardard
  Linux system should contain and how it should be organised. Android uses its own
  system which differs most noticably by the different filesystem structures and
  the use of user IDs to separate apps rather than users~\cite{linux_foundation_lsb_2015}.}, and with additional
patches) it can be ported to other architectures (such as X86 and MIPS), and
used in other devices (such as set-top boxes and TVs, watches, and cars) with
relative ease.

To give developers a somewhat stable base to develop for Google developed the
\ac{CTS}\footnote{\url{https://source.android.com/compatibility/cts/index.html}},
and \ac{CDD}\footnote{\url{https://source.android.com/compatibility/android-cdd.html}}.
The \ac{CTS} is a series of unit tests that check basic Android functionality and
behavior. The \ac{CDD} is a document that describes what hardware an Android device
should have and how the device and it's software should be built. If a device
manufacturer wishes their device to run Google's Play Store (the largest Android
app marketplace), then they are required to show they can pass the \ac{CTS} and are
in compliance with the \ac{CDD}.

\section{Authorization Logic and Fine Grained Permission Systems}
\label{sec:authorization-logic}

\todo{Introduce the subject and show the evolution from policymaker.}

\subsection{PolicyMaker and Keynote}

PolicyMaker~\cite{blaze_decentralized_1996} was created to give a
language for permitted actions.  X.509 and PGP certificates had given
a mechanism for identifying users; at the time however, they did not
give any means to link the users to what users were allowed to do.

To describe the authorizations trust information is contained within
assertions.  A collection of assertions form the policy.  An assertion
has a source (either the local policy document or a public key). The
source \emph{asserts} that a key (or more complex arrangements such as
three of four keys) is permitted to perform any action that matches
the \emph{filter}.  The filter itself is essentially an arbitrary
program that can decide if an action is permitted.
Blaze~\etal~provide examples using regular expressions and a reduced
version of AWK~\cite{aho_awk-pattern_1979} they call \emph{AWKWARD},
though they note that any programming language could be used.  The
collection of these authorizations on a machine forms the policy for
the device which can be queried by a PolicyMaker key \emph{requesting}
a given action.

Blaze~\etal~give an example of this scheme being used as part of an
email server.  A user, Alice, identified by key \texttt{0x12345678} is
permitted to send emails with the from header set to Alice and the
organisation set to Bob Labs.

A PolicyMaker instance is installed on a server and allowed to receive queries and give answers.
The policy is installed on the server as follows:

\begin{lstlisting}
policy ASSERTS
  pgp:'0x12345678'
  WHERE PREDICATE=regexp:'(From: Alice) &&
    (Organization: Bob Labs)';
\end{lstlisting}

When Alice tries to send an email using a PolicyMaker enhanced SMTP
client she signs and sends her message using her key.  The mailserver
checks the signature and queries the policy server with her message:

\begin{lstlisting}
  pgp:'0x12345678'
  REQUESTS  'From: Alice
             Organization: Bob Labs

             Hello World!';
\end{lstlisting}

If Alice's request is accepted then the SMTP server will send the
message.  If it doesn't match the policy then it won't.

PolicyMaker was used as the basis for the KeyNote Trust Management
System~\cite{blaze_role_1999,blaze_keynote:_1998} which simplified the
filter languages from any arbitrary language to a purpose built one
based on C that always returned a boolean answer, allowed the policy
server to do the signature verification instead of the querying
application, and tweaked the syntax for readability.  It was designed
to trade some of the generality of PolicyMaker for a more realistic
scenario using public-key infrastructure.

\todo{Go on to talk about how whilst these languages were general that was ultimately their downfall as policy filters were inevitable undecidable and could have unbounded complexity.  Contrast with secpal.}

\subsection{Binder}
\subsection{SPKI/SDSI}
\subsection{RT}
\subsection{DKAL}
\subsection{Cassandra}
\subsection{XACML}

XACML is a standardised policy language~\cite{oasis_extensible_2013} that can be
extended to fit many scenarios. It is an attribute based policy language, but
can also describe role-based policies; and has industrial support from
\emph{Oracle}. XACML policies are expressed as sets of \emph{rules} that
describe whether a specific action should be allowed or denied. When making a
\emph{request} if a rule's target matches the request then the appropriate
action should be taken. Rules are combined into policies and may contain many
rules which can contradict each other if multiple ones match a given request. To
handle contraditions between rules a \emph{combining algorithm} may be used to
decide how to proceed. Typical algorithms include:

\begin{description}
  \item[Permit-overrides] where if a single rule gives a permit result then the request is permitted.
  \item[Deny-overrides] where if a single rule gives a deny result then then the request is denied.
  \item[First-applicable] where the rules are given an order of precedence and the first rule in the order that gives a result decides the outcome.
  \item[Only-one-applicable] where only one rule may match, and if there are multiple matches an error is returned.
\end{description}

XACML is a powerful access control and policy language with a published
standard~\cite{oasis_extensible_2013}. It is generic and is used in industry as
a policy language for access control decisions, and there are tools available to
help policy authors write policies in it. Whilst XACML might seem like a
suitable language to model mobile ecosystems, it suffers from various issues.

Readability was a design goal for SecPAL. Its notation is similar to natural
language. Alternate notations based on XML do exist (Becker hints at them in the
SecPAL technical report~\cite{becker_secpal:_2010}); though these are to aid
computerised parsing of SecPAL not human legibility. In contrast, XACML's
default syntax is difficult to read. XACML policies are verbose, and written in
XML. To help developers write policies alternative notations are available that
compile into XACML's XML notation. ALFA is an alternate notation for
XACML~\cite{oasis_xacml_technical_comitee_abbreviated_????}. The XACML
developers maintain ALFA, however others notations exist including graphical
languages~\cite{henrik_nergaard_scratch-based_2015}, languages based on
propositional logic~\cite{zhang_synthesising_2004} and answer set
programming~\cite{ramli_xacml_2012}.

\todo{MORE DETAIL EMPHASISE SEMANTIC PROBLEMS}
XACML does not have well-defined semantics. XACML's designers used natural
language to describe the semantics of XACML. This has made the semantics
notoriously difficult to interpret~\cite{ramli_detecting_2015}. There have been
several attempts to describe XACML's semantics
formally~\cite{ramli_xacml_2012,ramli_logic_2014,bryans_reasoning_2005}. These
help specify XACML but the lack of a single standard semantics make it less
attractive to extend to a new domain. In contrast, SecPAL's semantics are given
precisely by Becker~\cite{becker_secpal:_2010}

Whilst XACML 3.0 does support delegation~\cite{oasis_xacml_2010}, earlier
versions do not. The XACML 3.0 standard was published in 2013, after deciding to
start work with SecPAL.

\todo{GIVE EXAMPLES OF XACMLS SYNTAX}

\subsection{Dr.~Android and Mr.~Hide}
\subsection{Aurasium}
\subsection{CRePE}
\subsection{Kirin}
\subsection{SEAndroid}

\section{Static analysis tools}

There have been many static tools developed that can infer complex
properties about
apps~\cite{felt_android_2011,song_integrated_2016,antonin_carette_investigating_2017,schmidt_static_2009,enck_taintdroid:_2014}.
Leveraging these tools in a policy language lets us make statements about the
properties they can infer, without having to reimplement the functionality.
Despite the power of these tools it is not obvious how they should integrate
with the policies surrounding the mobile ecosystem. Running and configuring each
It isn't clear when each tool should run, or how to configure them to enforce a
policy rule. By incorporating these tools into a policy language, such as
SecPAL, we can act as a glue-layer between the policies of the mobile ecosystem
and the research into the properties of code.

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ch7.tex"
%%% End:
