\documentclass[thesis.tex]{subfiles}
\begin{document}
\chapter{Background}

\section{The mobile ecosystem}\label{sec:mobile-ecosystem}

This dissertation talks about the policies surrounding \emph{mobile
ecosystems}; but what, precisely, do we mean by the \emph{mobile
ecosystem}?  A cow after all is both mobile and has an ecosystem of
grass, farmers, and other cows surrounding it.  Succinctly when we
refer to the mobile ecosystem we are referring to \textbf{the
interactions surrounding the use of smart phones and tablet
computers}.  To fully understand the scale of the ecosystem however,
it is best to describe some of the history surrounding it.

\subsection{Mobile devices: the story so far}

Some of the earliest mobile devices were the \acp{PDA} devices of the
early 90s.  The earliest devices, such as Apple's Newton, were
portable miniature computers designed to store personal information,
calendars and notes.  Developers could even program additional apps
for them (in the case of the Newton using Apple's Dylan language).  At
the time mobile phones were just portable telephones, but starting
with the IBM Simon in 1994 these devices started to have some of the
functionality of the \ac{PDA}, becoming what would later be called a
\emph{smart phone}.  The big advantage of these early smart phones
over the \ac{PDA} was they had a telephone connection.  The earliest
devices allowed their users to access email and fax, as well as
managing personal information.  The early smart phones were somewhat
underpowered compared to the \ac{PDA} devices so both continued to
develop alongside one another, and started to become more affordable.

In 1998 the Symbian OS was released.  Developed by Psion (who made
\acp{PDA}), and Motorola, Ericsson and Nokia (all phone
manufacturers).  By the early 2000s it would start to become the
dominant smart phone OS.  These devices could install apps, written in
C++ or Java (if the phone supported JME). They had cameras, could play
music. They even had early malware which would illicitly send texts to
premium rate numbers.  They were the forebears of the \emph{modern}
smart phone.
They were also starting to become affordable, with the lowest end
models starting to being affordable by children and
teenagers\footnote{If you saved up for what seemed like
  forever$\ldots$}.  Devices like Nokia's N-Gage were marketed directly
towards these younger users and featured games users could buy for
their devices.

In the mid-2000s we first start to see the mobile
ecosystem proper.  We have users with different devices, downloading
apps from different sources (not all legitimate).  These devices
contained personal information of the \acp{PDA}, but also photographs
and music.  User's could browse the web, and send each other pictures.
With increasing amounts of personal information malware authors
started to take note.  In a blog post from 2006 for Symantec, Chien
noted~\cite{eric_chien_spyware_2006}:

\begin{quote}
  ``While threats exist and are actively spreading, we are probably
  still years away from the situation we have with the Microsoft Windows
  [$\cdots$] We have already seen spyware applications for mobile devices
  (e.g. Spyware.Flexispy) that can monitor activities on the mobile
  device and then send them to a remote server. [$\cdots$] Just as
  worrying is the fact that the adware market is just beginning to take
  notice of mobile devices. Already some Bluetooth advertising schemes
  have been tested, where a bus stop is outfitted with a device that
  just spams out messages via Bluetooth.

  [$\cdots$]
  
  So, while worms and Trojans already exist for the mobile
  platforms, spyware and adware applications are just now gaining a
  foothold in the mobile device space. Spyware and adware pose a
  potentially large security issue in the near future, as the companies
  that produce such applications are less affected by the natural
  limiting factors.''
\end{quote}

In 2008 Apple released the first iPhone, and shortly after Google
released the Android OS.  Symbian would release its final version in
2012, with Android as the dominant OS on most devices.  These
operating systems differed from past efforts, and conventional desktop
OS, in that they were far more controlled than previous systems.
Apple's devices cannot run un-vetted code or install software from
outside of its App Store, which Apple controlled.  Android devices
offered a similar, though less heavily vetted, app
marketplace~\cite{oberheide_dissecting_2012}. Whilst Android users
could install software from other sources, the option was hidden by
default.  As well as restrictions to software, these devices were also
better protected.  Devices no longer had an all powerful \emph{root}
account.  APIs were provided that restricted malicious behaviors.
One example was stopping SMSs being sent programatically to premium
rate accounts; essentially ending a monetization technique that had
been prevelent in malware before.

With iOS and Android user's became more aware about privacy on their
devices.  A survey in 2012 by Chin~et~al{.} found that users were more
concerned about privacy on their mobile devices, than on their
laptops~\cite{chin_measuring_2012}. Users of a smartphone are more
likely to install an app that came recommended from a friend, was
popular or was free.  The drive for ever cheaper apps, particularly on
Android where users were even less likely to pay for software, lead to
many developers adding adware and tracking libraries into their apps.
These libraries accomplished a variety of tasks ranging from crash and
error tracking, to collecting personal data to be sold to advertisers
to subsidize the app's price~\cite{seungyeop_han_study_2012}.

This dynamic between users who were increasingly concerned about their
privacy and apps which were increasingly privacy invading, lead many
to argue that the mobile device operating systems needed better
controls for what data and permissions an app could
have~\cite{leontiadis_dont_2012}.  Many different schemes were
suggested to fix this and provide finer privacy
controls~\cite{jeon_dr._2012,beresford_mockdroid:_2011,conti_crepe:_2010,backes_appguard_2013}
(some of which will be described further in
\autoref{chap:related-work}).  In general, however, users did not
really understand the how app permissions
worked~\cite{felt_android_2012}.  By 2017 (and the present day) iOS
and Android had settled on a model where user's were asked by their
devices if an app could access certain data when it first requested it
and then the user could revoke that decision later if they wished.

Mobile devices became more ubiquitous, and \acp{PDA} reappeared now
called \emph{tablets} or \emph{iPads}.  These devices were identical
to the smart phones, but larger and they generally did not have a
cellular data connection instead using wifi. They couldn't send
texts or make phone calls but a shift away from traditional SMS and
cellular phone calls to internet backed communications such as
WhatsApp, iMessage, Skype and FaceTime meant these devices were
essentially interchangeable with smart phones.

Advances in secure co-processors meant that mobile devices are even
more capable.  Banks allow users to link their devices to
their bank accounts and use their device, or even the new \emph{smart
  watches} as a debit card.  This quickly became a common and ubiquitous
payment method quickly with even street vendors, who hadn't taken
cards previously, accepting contactless payment via a mobile device.

Mobile devices now record increasingly personal information.  Smart
watches record and share a user's pulse with others. Mobile health
apps are made to track and monitor medical conditions. In the US, the
\ac{HIPAA} requires that healthcare providers transmit medical
information securely, but many apps have basic security
problems~\cite{fahl_why_2012}, and many of the healthcare apps do not
handle the medical information securely~\cite{knorr_privacy_2015}.

\subsection{The Mobile Ecosystem and the need for Policies}

With mobile devices becoming increasingly capable and managing ever
increasing amounts of information there is a need to manage how the
devices behave.  As users become aware of the privacy implications of
their devices, they express preferences about which apps they want to
install~\cite{sadeh_understanding_2009}, even if they do not follow
through on their preferences~\cite{hallett_apppal_2016}.  Employees
now bring their mobile devices to work and use them to access company
email and documents.  In response to this companies publish mobile
device policies that describe how the devices should be used within
the company.  They may also use \ac{MDM} software to enforce the
policies.  If a company wishes to use an app for business purposes
there may be regulation they need to follow, such as \ac{HIPAA}.

These policies vary in terms of formality.  A user may never write
their privacy preferences in a formal language, but they may make
decisions guided by them.  For example which apps to install and which
to avoid.  They may make decisions based on what their friends have
told them, or what a review said about the app.  By describing the
policy in a formal language we can start to express the policy more
rigorously.  We can start to make comparisons between users, and with
rules for checking the policy start to help the user to make decisions
more accurately, or measure the extent a user follows their stated
policy~\cite{hallett_apppal_2016}.  

A company looking to control the mobile devices their employees bring
to work might write a \ac{BYOD} policy.  They might also use \ac{MDM}
software to control some aspects of their devices.  The company might
write these with varying degrees of formality but often they are
written using natural language.  This adds vagueness and can lead to
confusion as to how a policy should be implemented.  Using formal
languages we can model the policies precisely, helping clarify their
meanings and make precise comparisons between different policies.  We
can tie the rules in the \ac{BYOD} policies to the \ac{MDM} tools used
to implement them.

If a company needs to use apps which conform with a policy such as
\ac{HIPAA} they could use static analysis tools to check for some
aspects of the policy.  Perhaps the company might use
Mallodroid~\cite{fahl_why_2012} to detect when data is sent
unencrypted.  It is important, however, not to confuse the tools and
techniques we might use to implement parts of a policy with the end
goal of ensuring that the policy is followed.  A formal language that
lets us tie the policy to its implementation can help show how the
policy is checked.  It lets us see what rules from the policy are
checked for by which tools, and identify gaps where the policy is not
being checked.

When describing how mobile phones had evolved, we described how we
arrived with two main operating systems for mobile devices: iOS and
Android.  The trust models in the systems differ, as do the
assumptions about what an app can do when running on each system.
There are also similarities.  iOS and Android (from Android M) have a
similar permissions system for apps.  When people make comparisons
between them, however, the differences are often vague.  iOS is a
\emph{walled garden}.  Android is \emph{more open}.  Again, by using
formal languages we can start to make comparisons that are precise and
show the differences clearly.

We need an authorization logic for mobile ecosystems.

\section{SecPAL}

\todo{Give the briefest of overviews of SecPAL.  Explain what it was designed for, but leave most of the description for the AppPAL chapter.}

SecPAL was originally intended to model and enforce access control
policies in grid computing
systems~\cite{becker_secpal:_2010}. Flexibility is part of SecPAL's
goals, however. At its core, SecPAL is a language with a simple
grammar (\autoref{fig:secpal-grammar}) and three evaluation rules
(\autoref{fig:secpal-rules}). The language's simplicity makes it easy
to apply to a new domain by instantiating it with predicates and
constraints that describe the domain. This simplicity does not come at
the cost of its expressiveness. SecPAL supports delegation, and
arbitrary constraints, as well as role and attribute based policies
styles. Other domains have successfully used variants of SecPAL to
describe their policies. Humphrey~\etal{} instantiated SecPAL with
predicates for the GridFTP protocol to create a Grid access control
policy language~\cite{humphrey_fine-grained_2007}. Aziz~\etal{}
created SecPAL4DSA by adding predicates for data-sharing
agreements~\cite{aziz_secpal4dsa:_2011}.  Becker~\etal{} added
predicates for describing \ac{PII}-handling preferences and created
SecPAL4P~\cite{becker_framework_2009}.

\begin{figure}
  \newcommand{\bracetext}[1]{\text{\sffamily #1}}
  \newcommand{\smalltext}[1]{\text{\ttfamily\small #1}}
  \centering
  \begin{equation*}
    \begin{array}{r l}
      \overbrace{\smalltext{`user'}}^{\bracetext{speaker}} &
                                                             \smalltext{ says }\overbrace{\overbrace{\smalltext{ App }}^{\bracetext{subject}}\overbrace{\smalltext{ isRunnable}}^{\bracetext{predicate}}}^{\bracetext{fact}} \\
                                                           & \overbrace{\smalltext{ if App isFree}}^{\bracetext{condition}} \\
                                                           & \overbrace{\smalltext{ where hasPermission(App, `INTERNET') = true}}^{\bracetext{constraint}}.
    \end{array}
  \end{equation*}
  \caption{Structure of a SecPAL assertion.}
  \label{fig:assertion}
\end{figure}

\begin{figure}\centering
  \begin{tabular}{l p{0.7\linewidth}}
    \toprule
    $AC,\theta \vdash q$                     & Defining relation. A query assertion $q$ is valid given the assertions contained in the assertion context $AC$ and a variable substitution $\theta$. \\
    $\epsilon$                               & The empty substitution.                                                                                                                              \\
    \midrule
    $AC,\theta \vdash e \text{ says } fact$  & if $AC,\infty \models e\theta \text{ says } fact\theta$ and $dom(\theta) \subseteq vars(e \text{ says } fact)$                                       \\
    $AC,\theta_1\theta_2 \vdash q_1, q_2$    & if $AC,\theta_1 \vdash q_1$ and $AC,\theta_2 \vdash_2 q_2\theta_1$                                                                                   \\
    $AC,\theta \vdash q_1 \text{ or } q_2$   & if $AC,\theta \vdash q_1$ or $AC,\theta \vdash q_2$                                                                                                  \\
    $AC,\epsilon \vdash \mathsf{not}(q)$     & if $AC,\epsilon \not\vdash q$ and $vars(q) = \emptyset$                                                                                              \\
    $AC,\epsilon \vdash c$                   & if $\models c$                                                                                                                                       \\
    \bottomrule                             \\
  \end{tabular}
  \caption[SecPAL's semantics.]{SecPAL's semantics as described by Becker~\cite{becker_secpal:_2010}.}
\end{figure}

\newcommand{\bnfcomment}[1]{\slshape{\color{gray} (#1)}}
\newcommand{\secpal}[1]{\texttt{#1}}
\begin{figure}\footnotesize
  \begin{tabular}{r r l c}
    e          & $\Coloneqq$ & \secpal{x}                                       & \bnfcomment{variables}         \\
               & $\vert$     & \secpal{A}                                       & \bnfcomment{constants}         \\
    pred       & $\Coloneqq$ & \secpal{has} $\vert$ \secpal{can} $\vert$ \dots  & \bnfcomment{predicates}        \\
    D          & $\Coloneqq$ & 0                                                & \bnfcomment{no delegation}     \\
               & $\vert$     & $\infty$                                         & \bnfcomment{delegation}        \\
    vp         & $\Coloneqq$ & pred e$_1$ \dots e$_n$                           & \bnfcomment{verb phrase}       \\
               & $\vert$     & \secpal{can-say}$_D$ fact                       \\
               & $\vert$     & \secpal{can-act-as}  e                          \\
    f          & $\Coloneqq$ & e vp                                             & \bnfcomment{fact}              \\
    claim      & $\Coloneqq$ & f \secpal{if} f$_1$,\dots, f$_n$; c             \\
    assert     & $\Coloneqq$ & e \secpal{says} claim.                          \\
    AC         & $\Coloneqq$ & assert$_1$ \dots assert$_n$                      & \bnfcomment{assertion context} \\
    c          & $\Coloneqq$ & $\top$                                           & \bnfcomment{no constraint}     \\
               & $\vert$     & e$^\prime_1 =$ e$^\prime_2$                      & \bnfcomment{constraints}       \\
               & $\vert$     & \dots                                           \\
    e$^\prime$ & $\Coloneqq$ & e $\vert$ function(e$_1$,\dots e$_n$)           \\
  \end{tabular}
  \caption{BNF description of SecPAL.}
  \label{fig:secpal-grammar}
\end{figure}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../ch2"
%%% End:
