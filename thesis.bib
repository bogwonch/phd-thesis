
@incollection{hallett_apppal_2016,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {{AppPAL} for {Android}},
	copyright = {©2016 Springer International Publishing Switzerland},
	isbn = {978-3-319-30805-0 978-3-319-30806-7},
	url = {http://link.springer.com/chapter/10.1007/978-3-319-30806-7_14},
	abstract = {It can be difficult to find mobile apps that respect one’s security and privacy. Businesses rely on employees enforcing company mobile device policies correctly. Users must judge apps by the information shown to them by the store. Studies have found that most users do not pay attention to an apps permissions during installation [19] and most users do not understand how permissions relate to the capabilities of an app [30]. To address these problems and more, we present AppPAL: a machine-readable policy language for Android that describes precisely when apps are acceptable. AppPAL goes beyond existing policy enforcement tools, like Kirin [16], adding delegation relationships to allow a variety of authorities to contribute to a decision. AppPAL also acts as a “glue”, allowing connection to a variety of local constraint checkers (e.g., static analysis tools, packager manager checks) to combine their results. As well as introducing AppPAL and some examples, we apply it to explore whether users follow certain intended policies in practice, finding privacy preferences and actual behaviour are not always aligned in the absence of a rigorous enforcement mechanism.},
	language = {en},
	number = {9639},
	urldate = {2016-05-05},
	booktitle = {Engineering {Secure} {Software} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Hallett, Joseph and Aspinall, David},
	editor = {Caballero, Juan and Bodden, Eric and Athanasopoulos, Elias},
	month = apr,
	year = {2016},
	note = {DOI: 10.1007/978-3-319-30806-7\_14},
	keywords = {Algorithm Analysis and Problem Complexity, Computer Communication Networks, Data Encryption, Math Applications in Computer Science, Models and Principles, Software Engineering/Programming and Operating Systems},
	pages = {216--232},
	file = {Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/3SDPZK2N/978-3-319-30806-7_14.html:text/html}
}

@techreport{oasis_extensible_2013,
	title = {{eXtensible} {Access} {Control} {Markup} {Language} ({XACML}) {Version} 3.0},
	url = {http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-os-en.pdf},
	urldate = {2016-05-03},
	institution = {OASIS},
	author = {{OASIS}},
	month = jan,
	year = {2013},
	file = {eXtensible Access Control Markup Language (XACML) Version 3.0 - xacml-3.0-core-spec-os-en.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/7EMQZDG8/xacml-3.0-core-spec-os-en.pdf:application/pdf}
}

@inproceedings{hayton_access_1998,
	title = {Access {Control} in an {Open} {Distributed} {Environment}},
	doi = {10.1109/SECPRI.1998.674819},
	abstract = {We describe an architecture for secure, independent, interworking services (Oasis). Each service is made responsible for the classification of its clients into named roles, using a formal logic to specify precise conditions for entering each role. A client becomes authenticated by presenting credentials to a service that enable the service to prove that the client conforms to its policy for entry to a particular role. During authentication a data structure is created that embodies the proof. An authenticated client is issued a role membership certificate (RMC) for its subsequent use with that service. An RMC is an encryption-protected capability which includes the role name, the identity of the principal to which it was issued and a reference to the issuing service. A proof rule of one service may refer to an authenticated user of another; that is, an RMC issued by one service may be required as a credential during authentication by another. A dynamic proof tree may thus be built which exhibits amongst other things the trust relationships between the services which the client has entered. The paper shows how a service may define a set of proof rules (Horn clauses) that specify who may use it and in what way. Delegation of rights may be expressed naturally within these rules. It goes on to present the design details of the system. The system is inherently decentralised and has a tuneable reaction to network or server failure which allows services to make appropriate decisions when authorization or revocation information is unavailable. A prototype system has been implemented and tested},
	booktitle = {1998 {IEEE} {Symposium} on {Security} and {Privacy}, 1998. {Proceedings}},
	author = {Hayton, R. J. and Bacon, J. M. and Moody, K.},
	month = may,
	year = {1998},
	keywords = {access control, authenticated client, authenticated user, Authentication, authorisation, authorization, Chromium, client authentication, client-server systems, credentials, cryptography, data structure, decentralised system, delegation of rights, dynamic proof tree, encryption-protected capability, formal logic, Horn clauses, Identity-based encryption, internetworking, interworking services, Laboratories, Logic, message authentication, named roles, Network servers, Oasis, open distributed environment, open systems, proof rule, Prototypes, revocation information, RMC, role membership certificate, role name, server failure, System testing, theorem proving, trust relationship, tuneable reaction},
	pages = {3--14},
	file = {IEEE Xplore Abstract Record:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/99MSQP4M/articleDetails.html:text/html;IEEE Xplore Full Text PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/PF9EFQJE/Hayton et al. - 1998 - Access control in an open distributed environment.pdf:application/pdf}
}

@article{ramli_detecting_2015,
	title = {Detecting {Incompleteness}, {Conflicting} and {Unreachability} {XACML} {Policies} using {Answer} {Set} {Programming}},
	url = {http://arxiv.org/abs/1503.02732},
	abstract = {Recently, XACML is a popular access control policy language that is used widely in many applications. Policies in XACML are built based on many components over distributed resources. Due to the expressiveness of XACML, it is not trivial for policy administrators to understand the overall effect and consequences of XACML policies they have written. In this paper we show a mechanism and a tool how to analyses big access control policies sets such as (i) incompleteness policies, (ii) conflicting policies, and (iii) unreachable policies. To detect these problems we present a method using Answer Set Programming (ASP) in the context of XACML 3.0.},
	urldate = {2016-04-28},
	journal = {arXiv:1503.02732 [cs]},
	author = {Ramli, Carroline Dewi Puspa Kencana},
	month = mar,
	year = {2015},
	note = {arXiv: 1503.02732},
	keywords = {Computer Science - Cryptography and Security},
	file = {arXiv\:1503.02732 PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/NJ85GID8/Ramli - 2015 - Detecting Incompleteness, Conflicting and Unreacha.pdf:application/pdf;arXiv.org Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/HZINUUVP/1503.html:text/html}
}

@article{becker_secpal:_2010,
	title = {{SecPAL}: {Design} and semantics of a decentralized authorization language},
	volume = {18},
	shorttitle = {{SecPAL}},
	url = {http://dx.doi.org/10.3233/JCS-2009-0364},
	doi = {10.3233/JCS-2009-0364},
	abstract = {We present a declarative authorization language. Policies and credentials are expressed using predicates defined by logical clauses, in the style of constraint logic programming. Access requests are mapped to logical authorization queries, consisting of predicates and constraints combined by conjunctions, disjunctions, and negations. Access is granted if the query succeeds against the current database of clauses. Predicates ascribe rights to particular principals, with flexible support for delegation and revocation. At the discretion of the delegator, delegated rights can be further delegated, either to a fixed depth, or arbitrarily deeply. Our language strikes a careful balance between syntactic and semantic simplicity, policy expressiveness, and execution efficiency. The syntax is close to natural language, and the semantics consists of just three deduction rules. The language can express many common policy idioms using constraints, controlled delegation, recursive predicates, and negated queries. We describe an execution strategy based on translation to Datalog with Constraints, and table-based resolution. We show that this execution strategy is sound, complete, and always terminates, despite recursion and negation, as long as simple syntactic conditions are met.},
	number = {4},
	urldate = {2013-11-15},
	journal = {Journal of Computer Security},
	author = {Becker, Moritz Y. and Fournet, Cédric and Gordon, Andrew D.},
	month = jan,
	year = {2010},
	note = {00059},
	pages = {619--665},
	file = {51076944(1).pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/NT8WZXM7/51076944(1).pdf:application/pdf;MetaPress Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/RDZWBVNC/v2513jj40jk20201.html:text/html;SecPAL\: Design and semantics of a decentralized authorization language.\: EBSCOhost:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/I4UPX4W2/pdfviewer.html:text/html;SecPal-Reference.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/A6TC645Q/SecPal-Reference.pdf:application/pdf}
}

@techreport{mobileiron_security_labs_q4_2015,
	title = {Q4 {Mobile} {Security} and {Risk} {Review}},
	institution = {MobileIron Security Labs},
	author = {{MobileIron Security Labs}},
	month = dec,
	year = {2015},
	file = {Q4 Mobile Security and Risk Review:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/QZE9VHH5/Q4 Mobile Security and Risk Review.pdf:application/pdf}
}

@inproceedings{zhang_synthesising_2004,
	address = {New York, NY, USA},
	series = {{FMSE} '04},
	title = {Synthesising {Verified} {Access} {Control} {Systems} in {XACML}},
	isbn = {978-1-58113-971-6},
	url = {http://doi.acm.org/10.1145/1029133.1029141},
	doi = {10.1145/1029133.1029141},
	abstract = {The \textit{eXtensible Access Control Markup Language} (XACML) was proposed by the OASIS committee to be used as a standard language in e-business [6]. However, policy files written in XACML are hard to read and analyse directly. In this paper, we present a tool which generates verified XACML scripts from access control system descriptions in simple but expressive language proposed in [3], which admits algorithmic verification of access control systems against appropriately formalised policies. This allows the generation of XACML scripts for systems that can be formally verified to be implementing the relevant policies.},
	urldate = {2016-04-28},
	booktitle = {Proceedings of the 2004 {ACM} {Workshop} on {Formal} {Methods} in {Security} {Engineering}},
	publisher = {ACM},
	author = {Zhang, Nan and Ryan, Mark and Guelev, Dimitar P.},
	year = {2004},
	keywords = {access control model, access control policy language, XACML},
	pages = {56--65},
	file = {ACM Full Text PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/N9EAQFGI/Zhang et al. - 2004 - Synthesising Verified Access Control Systems in XA.pdf:application/pdf}
}

@techreport{schulze_byod_2016,
	title = {{BYOD} \& {Mobile} {Security} 2016 {Spotlight} {Report}},
	institution = {LinkedIn Information Security},
	author = {Schulze, Holger},
	year = {2016},
	file = {BYOD-and-Mobile-Security-Report-2016-01.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/5IVJT93R/BYOD-and-Mobile-Security-Report-2016-01.pdf:application/pdf}
}

@incollection{masi_formalisation_2012,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Formalisation and {Implementation} of the {XACML} {Access} {Control} {Mechanism}},
	copyright = {©2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-28165-5 978-3-642-28166-2},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-28166-2_7},
	abstract = {We propose a formal account of XACML, an OASIS standard adhering to the Policy Based Access Control model for the specification and enforcement of access control policies. To clarify all ambiguous and intricate aspects of XACML, we provide it with a more manageable alternative syntax and with a solid semantic ground. This lays the basis for developing tools and methodologies which allow software engineers to easily and precisely regulate access to resources using policies. To demonstrate feasibility and effectiveness of our approach, we provide a software tool, supporting the specification and evaluation of policies and access requests, whose implementation fully relies on our formal development.},
	language = {en},
	number = {7159},
	urldate = {2016-04-07},
	booktitle = {Engineering {Secure} {Software} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Masi, Massimiliano and Pugliese, Rosario and Tiezzi, Francesco},
	editor = {Barthe, Gilles and Livshits, Benjamin and Scandariato, Riccardo},
	month = feb,
	year = {2012},
	note = {00029 
DOI: 10.1007/978-3-642-28166-2\_7},
	keywords = {CASE tools, Computer Communication Networks, Data Encryption, Data Structures, Cryptology and Information Theory, formal semantics, Math Applications in Computer Science, Models and Principles, PBAC, Software Engineering/Programming and Operating Systems, XACML},
	pages = {60--74},
	file = {chp%3A10.1007%2F978-3-642-28166-2_7.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/VBIQWTDS/chp%3A10.1007%2F978-3-642-28166-2_7.pdf:application/pdf;Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/SMENU9QZ/978-3-642-28166-2_7.html:text/html}
}

@inproceedings{bryans_reasoning_2005,
	address = {New York, NY, USA},
	series = {{SWS} '05},
	title = {Reasoning {About} {XACML} {Policies} {Using} {CSP}},
	isbn = {978-1-59593-234-1},
	url = {http://doi.acm.org/10.1145/1103022.1103028},
	doi = {10.1145/1103022.1103028},
	abstract = {In this work we explore the use of process algebra in formalising and analysing access control policies. We do this by considering a standard access control language (XACML) and show how the core concepts in the language can be represented in CSP. We then show how properties of these policies may also be described in CSP, and how model checking may be used to verify that a policy meets the property.We further consider how we may introduce a notion of workflow into this framework, and show that a simple appreciation of the workflow context may limit the things we need to verify about a policy.},
	urldate = {2016-04-28},
	booktitle = {Proceedings of the 2005 {Workshop} on {Secure} {Web} {Services}},
	publisher = {ACM},
	author = {Bryans, Jery},
	year = {2005},
	keywords = {access control, CSP, santic models, XACML},
	pages = {28--35},
	file = {ACM Full Text PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/GZFXHH32/Bryans - 2005 - Reasoning About XACML Policies Using CSP.pdf:application/pdf}
}

@incollection{ramli_xacml_2012,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {{XACML} 3.0 in {Answer} {Set} {Programming}},
	copyright = {©2013 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-38196-6 978-3-642-38197-3},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-38197-3_7},
	abstract = {We present a systematic technique for transforming XACML 3.0 policies in Answer Set Programming (ASP). We show that the resulting logic program has a unique answer set that directly corresponds to our formalisation of the standard semantics of XACML 3.0 from [9]. We demonstrate how our results make it possible to use off-the-shelf ASP solvers to formally verify properties of access control policies represented in XACML, such as checking the completeness of a set of access control policies and verifying policy properties.},
	language = {en},
	number = {7844},
	urldate = {2016-05-03},
	booktitle = {Logic-{Based} {Program} {Synthesis} and {Transformation}},
	publisher = {Springer Berlin Heidelberg},
	author = {Ramli, Carroline Dewi Puspa Kencana and Nielson, Hanne Riis and Nielson, Flemming},
	editor = {Albert, Elvira},
	month = sep,
	year = {2012},
	note = {DOI: 10.1007/978-3-642-38197-3\_7},
	keywords = {access control, Answer Set Programming, Artificial Intelligence (incl. Robotics), Discrete Mathematics in Computer Science, Logics and Meanings of Programs, Mathematical Logic and Formal Languages, policy language, Programming Techniques, Software Engineering, XACML},
	pages = {89--105},
	file = {Full Text PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/7IZEMRDM/Ramli et al. - 2012 - XACML 3.0 in Answer Set Programming.pdf:application/pdf;Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/NXMG4RF2/978-3-642-38197-3_7.html:text/html}
}

@techreport{oasis_xacml_2010,
	title = {{XACML} v3.0 {Administration} and  {Delegation} {Profile}},
	institution = {OASIS},
	author = {{OASIS}},
	month = aug,
	year = {2010},
	file = {xacml-3.0-administration-v1-spec-cs-01-en.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/7W7IDHTM/xacml-3.0-administration-v1-spec-cs-01-en.pdf:application/pdf}
}

@article{ramli_logic_2014,
	series = {Formal {Aspects} of {Component} {Software} ({FACS} 2011 selected \& extended papers)},
	title = {The logic of {XACML}},
	volume = {83},
	issn = {0167-6423},
	url = {http://www.sciencedirect.com/science/article/pii/S0167642313001238},
	doi = {10.1016/j.scico.2013.05.003},
	abstract = {We study the international standard XACML 3.0 for describing security access control policies in a compositional way. Our main contributions are (i) to derive a logic that precisely captures the intentions of the standard, (ii) to formally define a semantics for the XACML 3.0 component evaluation, and (iii) to define a semantics for the XACML 3.0 standard combining operators. To guard against modeling artefacts we provide an alternative lattice based way of characterizing the policy combining operators and we formally prove the equivalence of these approaches thereby increasing our faith in either one. We then discuss several ways of extending XACML: one direction is to extend XACML with new combining operators, and another direction is to incorporate the notion of conflict into XACML. We conclude by discussing the possibility of analysing XACML policies for gaps and conflicts.},
	urldate = {2016-05-03},
	journal = {Science of Computer Programming},
	author = {Ramli, Carroline Dewi Puspa Kencana and Nielson, Hanne Riis and Nielson, Flemming},
	month = apr,
	year = {2014},
	keywords = {access control, Composition policies, Control systems, XACML 3.0},
	pages = {80--105},
	file = {ScienceDirect Full Text PDF:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/JSRG5D28/Ramli et al. - 2014 - The logic of XACML.pdf:application/pdf;ScienceDirect Snapshot:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/6WDJ7DUG/S0167642313001238.html:text/html}
}

@article{bruns_access_2011,
	title = {Access {Control} via {Belnap} {Logic}: {Intuitive}, {Expressive}, and {Analyzable} {Policy} {Composition}},
	volume = {14},
	issn = {1094-9224},
	shorttitle = {Access {Control} via {Belnap} {Logic}},
	url = {http://doi.acm.org/10.1145/1952982.1952991},
	doi = {10.1145/1952982.1952991},
	abstract = {Access control to IT systems increasingly relies on the ability to compose policies. Hence there is benefit in any framework for policy composition that is intuitive, formal (and so “analyzable” and “implementable”), expressive, independent of specific application domains, and yet able to be extended to create domain-specific instances. Here we develop such a framework based on Belnap logic. An access-control policy is interpreted as a four-valued predicate that maps access requests to either grant, deny, conflict, or unspecified -- the four values of the Belnap bilattice. We define an expressive access-control policy language PBel, having composition operators based on the operators of Belnap logic. Natural orderings on policies are obtained by lifting the truth and information orderings of the Belnap bilattice. These orderings lead to a query language in which policy analyses, for example, conflict freedom, can be specified. Policy analysis is supported through a reduction of the validity of policy queries to the validity of propositional formulas on predicates over access requests. We evaluate our approach through firewall policy and RBAC policy examples, and discuss domain-specific and generic extensions of our policy language.},
	number = {1},
	urldate = {2016-04-15},
	journal = {ACM Trans. Inf. Syst. Secur.},
	author = {Bruns, Glenn and Huth, Michael},
	month = jun,
	year = {2011},
	note = {00042},
	keywords = {Access-control policy languages, bilattices, Multivalued logic},
	pages = {9:1--9:27},
	file = {Bruns_Huth_2011_Access Control via Belnap Logic.pdf:/home/user/.zotero/zotero/pbjoktzc.default/zotero/storage/GHBHGWVI/Bruns_Huth_2011_Access Control via Belnap Logic.pdf:application/pdf}
}